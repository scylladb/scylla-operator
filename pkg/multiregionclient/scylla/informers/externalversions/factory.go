// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
	"crypto/sha512"
	reflect "reflect"
	sync "sync"
	time "time"

	versioned "github.com/scylladb/scylla-operator/pkg/multiregionclient/scylla/clientset/versioned"
	internalinterfaces "github.com/scylladb/scylla-operator/pkg/multiregionclient/scylla/informers/externalversions/internalinterfaces"
	scylla "github.com/scylladb/scylla-operator/pkg/multiregionclient/scylla/informers/externalversions/scylla"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
	client           versioned.RemoteInterface
	namespace        string
	tweakListOptions internalinterfaces.TweakListOptionsFunc
	lock             sync.Mutex
	defaultResync    time.Duration
	customResync     map[reflect.Type]time.Duration

	informers 		 map[reflect.Type]map[string]cache.SharedIndexInformer
	startedInformers map[reflect.Type]map[string]chan struct{}
	unboundInformers map[reflect.Type]internalinterfaces.UnboundInformer
	eventHandlers map[reflect.Type][]cache.ResourceEventHandler
	credentialsHashes map[string]string
	stopCh <-chan struct{}
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		for k, v := range resyncConfig {
			factory.customResync[reflect.TypeOf(k)] = v
		}
		return factory
	}
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		factory.tweakListOptions = tweakListOptions
		return factory
	}
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption {
	return func(factory *sharedInformerFactory) *sharedInformerFactory {
		factory.namespace = namespace
		return factory
	}
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.RemoteInterface, defaultResync time.Duration) SharedInformerFactory {
	return NewSharedInformerFactoryWithOptions(client, defaultResync)
}

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.RemoteInterface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory {
	return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.RemoteInterface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory {
	factory := &sharedInformerFactory{
		client:           client,
		namespace:        v1.NamespaceAll,
		defaultResync:    defaultResync,
		informers:        make(map[reflect.Type]map[string]cache.SharedIndexInformer),
		startedInformers: make(map[reflect.Type]map[string]chan struct{}),
		customResync:     make(map[reflect.Type]time.Duration),
	}

	// Apply all options
	for _, opt := range options {
		factory = opt(factory)
	}

	return factory
}

// Start initializes all requested informers.
func (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {
	f.lock.Lock()
	defer f.lock.Unlock()

	if f.stopCh != nil {
		f.stopCh = stopCh
	}

	for informerType, informers := range f.informers {
		for dc, informer := range informers {
			if _, started := f.startedInformers[informerType][dc]; !started {
				sc := make(chan struct{})
				go func() {
					<-stopCh
					close(sc)
				}()

				go informer.Run(sc)
				if _, ok := f.startedInformers[informerType]; !ok {
					f.startedInformers[informerType] = map[string]chan struct{}{}
				}
				f.startedInformers[informerType][dc] = sc
			}
		}
	}
}

// InternalInformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, datacenter string, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
	f.lock.Lock()
	defer f.lock.Unlock()

	informerType := reflect.TypeOf(obj)
	datacenterInformers, registered := f.informers[informerType]
	if registered {
		informer, exists := datacenterInformers[datacenter]
		if exists {
			return informer
		}
	}

	resyncPeriod, exists := f.customResync[informerType]
	if !exists {
		resyncPeriod = f.defaultResync
	}

	informer := newFunc(f.client, datacenter, resyncPeriod, f.eventHandlers[informerType])
	if _, ok := f.informers[informerType]; !ok {
		f.informers[informerType] = map[string]cache.SharedIndexInformer{}
	}
	f.informers[informerType][datacenter] = informer

	if len(f.startedInformers) > 0 {
		sc := make(chan struct{})
		go func() {
			<-f.stopCh
			select{
			case <-sc:
			default:
				close(sc)
			}
		}()
		go informer.Run(sc)
		if _, ok := f.startedInformers[informerType]; !ok {
			f.startedInformers[informerType] = map[string]chan struct{}{}
		}
		f.startedInformers[informerType][datacenter] = sc
	}

	return informer
}

func (f *sharedInformerFactory) UnboundInformerFor(obj runtime.Object, newFunc internalinterfaces.NewUnboundInformerFunc) internalinterfaces.UnboundInformer {
	f.lock.Lock()
	defer f.lock.Unlock()

	informerType := reflect.TypeOf(obj)
	informer, exists := f.unboundInformers[informerType]
	if exists {
		return informer
	}

	informer = newFunc()
	f.unboundInformers[informerType] = informer

	return informer
}

func (f *sharedInformerFactory) AddEventHandlerFor(obj runtime.Object, handler cache.ResourceEventHandler) {
	f.lock.Lock()
	defer f.lock.Unlock()

	informerType := reflect.TypeOf(obj)
	f.eventHandlers[informerType] = append(f.eventHandlers[informerType], handler)
}

func (f *sharedInformerFactory) HasSyncedFor(obj runtime.Object) bool {
	f.lock.Lock()
	defer f.lock.Unlock()

	informerType := reflect.TypeOf(obj)
	for _, informer := range f.informers[informerType] {
		if !informer.HasSynced() {
			return false
		}
	}
	return true
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
type SharedInformerFactory interface {
	internalinterfaces.SharedInformerFactory

	Scylla() scylla.Interface
}

type DynamicDatacenters interface {
	OnUpdate(datacenter string, config []byte) error
	OnDelete(datacenter string) error
}

type DynamicSharedInformerFactory interface {
	SharedInformerFactory
	DynamicDatacenters
}

func (f *sharedInformerFactory) Scylla() scylla.Interface {
	return scylla.New(f, f.namespace, f.tweakListOptions)
}

func (f *sharedInformerFactory) OnUpdate(datacenter string, config []byte) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	hash := string(sha512.New().Sum(config))
	if credentialsHash, found := f.credentialsHashes[datacenter]; found && credentialsHash == hash {
		return nil
	}

	f.stopDatacenterInformers(datacenter)

	return nil
}

func (f *sharedInformerFactory) stopDatacenterInformers(datacenter string) {
	for informerType, dcInformers := range f.startedInformers {
		if stopCh, started := dcInformers[datacenter]; started {
			select {
			case <-stopCh:
			default:
				close(stopCh)
			}
		}
		delete(f.startedInformers[informerType], datacenter)
		delete(f.informers[informerType], datacenter)
	}

	delete(f.credentialsHashes, datacenter)
}

func (f *sharedInformerFactory) OnDelete(datacenter string) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	f.stopDatacenterInformers(datacenter)

	return nil
}
