// Code generated by go-swagger; DO NOT EDIT.

package config

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new config API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for config API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
FindConfigAbortOnLsaBadAlloc Abort when allocation in LSA region fails
*/
func (a *Client) FindConfigAbortOnLsaBadAlloc(params *FindConfigAbortOnLsaBadAllocParams) (*FindConfigAbortOnLsaBadAllocOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAbortOnLsaBadAllocParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_abort_on_lsa_bad_alloc",
		Method:             "GET",
		PathPattern:        "/config/abort_on_lsa_bad_alloc",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAbortOnLsaBadAllocReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAbortOnLsaBadAllocOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAbortOnLsaBadAllocDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAPIAddress Http Rest API address
*/
func (a *Client) FindConfigAPIAddress(params *FindConfigAPIAddressParams) (*FindConfigAPIAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAPIAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_api_address",
		Method:             "GET",
		PathPattern:        "/config/api_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAPIAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAPIAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAPIAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAPIDocDir The API definition file directory
*/
func (a *Client) FindConfigAPIDocDir(params *FindConfigAPIDocDirParams) (*FindConfigAPIDocDirOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAPIDocDirParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_api_doc_dir",
		Method:             "GET",
		PathPattern:        "/config/api_doc_dir",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAPIDocDirReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAPIDocDirOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAPIDocDirDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAPIPort Http Rest API port
*/
func (a *Client) FindConfigAPIPort(params *FindConfigAPIPortParams) (*FindConfigAPIPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAPIPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_api_port",
		Method:             "GET",
		PathPattern:        "/config/api_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAPIPortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAPIPortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAPIPortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAPIUIDir The directory location of the API GUI
*/
func (a *Client) FindConfigAPIUIDir(params *FindConfigAPIUIDirParams) (*FindConfigAPIUIDirOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAPIUIDirParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_api_ui_dir",
		Method:             "GET",
		PathPattern:        "/config/api_ui_dir",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAPIUIDirReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAPIUIDirOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAPIUIDirDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAuthenticator The authentication backend, used to identify users. The available authenticators are:

 org.apache.cassandra.auth.AllowAllAuthenticator : Disables authentication; no checks are performed.
 org.apache.cassandra.auth.PasswordAuthenticator : Authenticates users with user names and hashed passwords stored in the system_auth.credentials table. If you use the default, 1, and the node with the lone replica goes down, you will not be able to log into the cluster because the system_auth keyspace was not replicated.
Related information: Internal authentication
*/
func (a *Client) FindConfigAuthenticator(params *FindConfigAuthenticatorParams) (*FindConfigAuthenticatorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAuthenticatorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_authenticator",
		Method:             "GET",
		PathPattern:        "/config/authenticator",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAuthenticatorReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAuthenticatorOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAuthenticatorDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAuthorizer The authorization backend. It implements IAuthenticator, which limits access and provides permissions. The available authorizers are:

 AllowAllAuthorizer : Disables authorization; allows any action to any user.
 CassandraAuthorizer : Stores permissions in system_auth.permissions table. If you use the default, 1, and the node with the lone replica goes down, you will not be able to log into the cluster because the system_auth keyspace was not replicated.
Related information: Object permissions
*/
func (a *Client) FindConfigAuthorizer(params *FindConfigAuthorizerParams) (*FindConfigAuthorizerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAuthorizerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_authorizer",
		Method:             "GET",
		PathPattern:        "/config/authorizer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAuthorizerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAuthorizerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAuthorizerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAutoAdjustFlushQuota true: auto-adjust memtable shares for flush processes
*/
func (a *Client) FindConfigAutoAdjustFlushQuota(params *FindConfigAutoAdjustFlushQuotaParams) (*FindConfigAutoAdjustFlushQuotaOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAutoAdjustFlushQuotaParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_auto_adjust_flush_quota",
		Method:             "GET",
		PathPattern:        "/config/auto_adjust_flush_quota",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAutoAdjustFlushQuotaReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAutoAdjustFlushQuotaOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAutoAdjustFlushQuotaDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAutoBootstrap This setting has been removed from default configuration. It makes new (non-seed) nodes automatically migrate the right data to themselves. Do not set this to false unless you really know what you are doing.
Related information: Initializing a multiple node cluster (single data center) and Initializing a multiple node cluster (multiple data centers).
*/
func (a *Client) FindConfigAutoBootstrap(params *FindConfigAutoBootstrapParams) (*FindConfigAutoBootstrapOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAutoBootstrapParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_auto_bootstrap",
		Method:             "GET",
		PathPattern:        "/config/auto_bootstrap",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAutoBootstrapReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAutoBootstrapOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAutoBootstrapDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigAutoSnapshot Enable or disable whether a snapshot is taken of the data before keyspace truncation or dropping of tables. To prevent data loss, using the default setting is strongly advised. If you set to false, you will lose data on truncation or drop.
*/
func (a *Client) FindConfigAutoSnapshot(params *FindConfigAutoSnapshotParams) (*FindConfigAutoSnapshotOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigAutoSnapshotParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_auto_snapshot",
		Method:             "GET",
		PathPattern:        "/config/auto_snapshot",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigAutoSnapshotReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigAutoSnapshotOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigAutoSnapshotDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBackgroundWriterSchedulingQuota max cpu usage ratio (between 0 and 1) for compaction process. Not intended for setting in normal operations. Setting it to 1 or higher will disable it, recommended operational setting is 0.5.
*/
func (a *Client) FindConfigBackgroundWriterSchedulingQuota(params *FindConfigBackgroundWriterSchedulingQuotaParams) (*FindConfigBackgroundWriterSchedulingQuotaOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBackgroundWriterSchedulingQuotaParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_background_writer_scheduling_quota",
		Method:             "GET",
		PathPattern:        "/config/background_writer_scheduling_quota",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBackgroundWriterSchedulingQuotaReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBackgroundWriterSchedulingQuotaOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBackgroundWriterSchedulingQuotaDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBatchSizeFailThresholdInKb Fail any multiple-partition batch exceeding this value. 50kb (10x warn threshold) by default.
*/
func (a *Client) FindConfigBatchSizeFailThresholdInKb(params *FindConfigBatchSizeFailThresholdInKbParams) (*FindConfigBatchSizeFailThresholdInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBatchSizeFailThresholdInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_batch_size_fail_threshold_in_kb",
		Method:             "GET",
		PathPattern:        "/config/batch_size_fail_threshold_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBatchSizeFailThresholdInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBatchSizeFailThresholdInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBatchSizeFailThresholdInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBatchSizeWarnThresholdInKb Log WARN on any batch size exceeding this value in kilobytes. Caution should be taken on increasing the size of this threshold as it can lead to node instability.
*/
func (a *Client) FindConfigBatchSizeWarnThresholdInKb(params *FindConfigBatchSizeWarnThresholdInKbParams) (*FindConfigBatchSizeWarnThresholdInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBatchSizeWarnThresholdInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_batch_size_warn_threshold_in_kb",
		Method:             "GET",
		PathPattern:        "/config/batch_size_warn_threshold_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBatchSizeWarnThresholdInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBatchSizeWarnThresholdInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBatchSizeWarnThresholdInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBatchlogReplayThrottleInKb Total maximum throttle. Throttling is reduced proportionally to the number of nodes in the cluster.
*/
func (a *Client) FindConfigBatchlogReplayThrottleInKb(params *FindConfigBatchlogReplayThrottleInKbParams) (*FindConfigBatchlogReplayThrottleInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBatchlogReplayThrottleInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_batchlog_replay_throttle_in_kb",
		Method:             "GET",
		PathPattern:        "/config/batchlog_replay_throttle_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBatchlogReplayThrottleInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBatchlogReplayThrottleInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBatchlogReplayThrottleInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBroadcastAddress The IP address a node tells other nodes in the cluster to contact it by. It allows public and private address to be different. For example, use the broadcast_address parameter in topologies where not all nodes have access to other nodes by their private IP addresses.
If your Scylla cluster is deployed across multiple Amazon EC2 regions and you use the EC2MultiRegionSnitch , set the broadcast_address to public IP address of the node and the listen_address to the private IP.
*/
func (a *Client) FindConfigBroadcastAddress(params *FindConfigBroadcastAddressParams) (*FindConfigBroadcastAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBroadcastAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_broadcast_address",
		Method:             "GET",
		PathPattern:        "/config/broadcast_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBroadcastAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBroadcastAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBroadcastAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigBroadcastRPCAddress RPC address to broadcast to drivers and other Scylla nodes. This cannot be set to 0.0.0.0. If blank, it is set to the value of the rpc_address or rpc_interface. If rpc_address or rpc_interfaceis set to 0.0.0.0, this property must be set.

*/
func (a *Client) FindConfigBroadcastRPCAddress(params *FindConfigBroadcastRPCAddressParams) (*FindConfigBroadcastRPCAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigBroadcastRPCAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_broadcast_rpc_address",
		Method:             "GET",
		PathPattern:        "/config/broadcast_rpc_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigBroadcastRPCAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigBroadcastRPCAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigBroadcastRPCAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCacheHitRateReadBalancing This boolean controls whether the replicas for read query will be choosen based on cache hit ratio
*/
func (a *Client) FindConfigCacheHitRateReadBalancing(params *FindConfigCacheHitRateReadBalancingParams) (*FindConfigCacheHitRateReadBalancingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCacheHitRateReadBalancingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_cache_hit_rate_read_balancing",
		Method:             "GET",
		PathPattern:        "/config/cache_hit_rate_read_balancing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCacheHitRateReadBalancingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCacheHitRateReadBalancingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCacheHitRateReadBalancingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCasContentionTimeoutInMs The time that the coordinator continues to retry a CAS (compare and set) operation that contends with other proposals for the same row.
*/
func (a *Client) FindConfigCasContentionTimeoutInMs(params *FindConfigCasContentionTimeoutInMsParams) (*FindConfigCasContentionTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCasContentionTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_cas_contention_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/cas_contention_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCasContentionTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCasContentionTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCasContentionTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigClientEncryptionOptions Enable or disable client-to-node encryption. You must also generate keys and provide the appropriate key and certificate. No custom encryption options are currently enabled. The available options are:

 enabled : (Default: false ) To enable, set to true.
 certificate: (Default: conf/scylla.crt) The location of a PEM-encoded x509 certificate used to identify and encrypt the client/server communication.
 keyfile: (Default: conf/scylla.key) PEM Key file associated with certificate.
truststore : (Default: <system truststore> ) Location of the truststore containing the trusted certificate for authenticating remote servers.

The advanced settings are:

 priority_string : GnuTLS priority string controlling TLS algorithms used/allowed.
 require_client_auth : (Default: false ) Enables or disables certificate authentication.
Related information: Client-to-node encryption
*/
func (a *Client) FindConfigClientEncryptionOptions(params *FindConfigClientEncryptionOptionsParams) (*FindConfigClientEncryptionOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigClientEncryptionOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_client_encryption_options",
		Method:             "GET",
		PathPattern:        "/config/client_encryption_options",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigClientEncryptionOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigClientEncryptionOptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigClientEncryptionOptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigClusterName The name of the cluster; used to prevent machines in one logical cluster from joining another. All nodes participating in a cluster must have the same value.
*/
func (a *Client) FindConfigClusterName(params *FindConfigClusterNameParams) (*FindConfigClusterNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigClusterNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_cluster_name",
		Method:             "GET",
		PathPattern:        "/config/cluster_name",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigClusterNameReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigClusterNameOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigClusterNameDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigColumnIndexSizeInKb Granularity of the index of rows within a partition. For huge rows, decrease this setting to improve seek time. If you use key cache, be careful not to make this setting too large because key cache will be overwhelmed. If you're unsure of the size of the rows, it's best to use the default setting.
*/
func (a *Client) FindConfigColumnIndexSizeInKb(params *FindConfigColumnIndexSizeInKbParams) (*FindConfigColumnIndexSizeInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigColumnIndexSizeInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_column_index_size_in_kb",
		Method:             "GET",
		PathPattern:        "/config/column_index_size_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigColumnIndexSizeInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigColumnIndexSizeInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigColumnIndexSizeInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitFailurePolicy Policy for commit disk failures:

 die          Shut down gossip and Thrift and kill the JVM, so the node can be replaced.
 stop         Shut down gossip and Thrift, leaving the node effectively dead, but can be inspected using JMX.
 stop_commit  Shut down the commit log, letting writes collect but continuing to service reads (as in pre-2.0.5 Cassandra).
 ignore       Ignore fatal errors and let the batches fail.
*/
func (a *Client) FindConfigCommitFailurePolicy(params *FindConfigCommitFailurePolicyParams) (*FindConfigCommitFailurePolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitFailurePolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commit_failure_policy",
		Method:             "GET",
		PathPattern:        "/config/commit_failure_policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitFailurePolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitFailurePolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitFailurePolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogDirectory The directory where the commit log is stored. For optimal write performance, it is recommended the commit log be on a separate disk partition (ideally, a separate physical device) from the data file directories.
*/
func (a *Client) FindConfigCommitlogDirectory(params *FindConfigCommitlogDirectoryParams) (*FindConfigCommitlogDirectoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogDirectoryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_directory",
		Method:             "GET",
		PathPattern:        "/config/commitlog_directory",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogDirectoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogDirectoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogDirectoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogReuseSegments Whether or not to re-use commitlog segments when finished instead of deleting them. Can improve commitlog latency on some file systems.

*/
func (a *Client) FindConfigCommitlogReuseSegments(params *FindConfigCommitlogReuseSegmentsParams) (*FindConfigCommitlogReuseSegmentsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogReuseSegmentsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_reuse_segments",
		Method:             "GET",
		PathPattern:        "/config/commitlog_reuse_segments",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogReuseSegmentsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogReuseSegmentsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogReuseSegmentsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogSegmentSizeInMb Sets the size of the individual commitlog file segments. A commitlog segment may be archived, deleted, or recycled after all its data has been flushed to SSTables. This amount of data can potentially include commitlog segments from every table in the system. The default size is usually suitable for most commitlog archiving, but if you want a finer granularity, 8 or 16 MB is reasonable. See Commit log archive configuration.
Related information: Commit log archive configuration
*/
func (a *Client) FindConfigCommitlogSegmentSizeInMb(params *FindConfigCommitlogSegmentSizeInMbParams) (*FindConfigCommitlogSegmentSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogSegmentSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_segment_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/commitlog_segment_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogSegmentSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogSegmentSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogSegmentSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogSync The method that Scylla uses to acknowledge writes in milliseconds:

 periodic : Used with commitlog_sync_period_in_ms (Default: 10000 - 10 seconds ) to control how often the commit log is synchronized to disk. Periodic syncs are acknowledged immediately.
 batch : Used with commitlog_sync_batch_window_in_ms (Default: disabled **) to control how long Scylla waits for other writes before performing a sync. When using this method, writes are not acknowledged until fsynced to disk.
Related information: Durability
*/
func (a *Client) FindConfigCommitlogSync(params *FindConfigCommitlogSyncParams) (*FindConfigCommitlogSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_sync",
		Method:             "GET",
		PathPattern:        "/config/commitlog_sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogSyncReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogSyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogSyncDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogSyncBatchWindowInMs Controls how long the system waits for other writes before performing a sync in ''batch'' mode.
*/
func (a *Client) FindConfigCommitlogSyncBatchWindowInMs(params *FindConfigCommitlogSyncBatchWindowInMsParams) (*FindConfigCommitlogSyncBatchWindowInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogSyncBatchWindowInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_sync_batch_window_in_ms",
		Method:             "GET",
		PathPattern:        "/config/commitlog_sync_batch_window_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogSyncBatchWindowInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogSyncBatchWindowInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogSyncBatchWindowInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogSyncPeriodInMs Controls how long the system waits for other writes before performing a sync in ''periodic'' mode.
*/
func (a *Client) FindConfigCommitlogSyncPeriodInMs(params *FindConfigCommitlogSyncPeriodInMsParams) (*FindConfigCommitlogSyncPeriodInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogSyncPeriodInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_sync_period_in_ms",
		Method:             "GET",
		PathPattern:        "/config/commitlog_sync_period_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogSyncPeriodInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogSyncPeriodInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogSyncPeriodInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogTotalSpaceInMb Total space used for commitlogs. If the used space goes above this value, Scylla rounds up to the next nearest segment multiple and flushes memtables to disk for the oldest commitlog segments, removing those log segments. This reduces the amount of data to replay on startup, and prevents infrequently-updated tables from indefinitely keeping commitlog segments. A small total commitlog space tends to cause more flush activity on less-active tables.
Related information: Configuring memtable throughput
*/
func (a *Client) FindConfigCommitlogTotalSpaceInMb(params *FindConfigCommitlogTotalSpaceInMbParams) (*FindConfigCommitlogTotalSpaceInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogTotalSpaceInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_total_space_in_mb",
		Method:             "GET",
		PathPattern:        "/config/commitlog_total_space_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogTotalSpaceInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogTotalSpaceInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogTotalSpaceInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCommitlogUseoDsync Whether or not to use O_DSYNC mode for commitlog segments IO. Can improve commitlog latency on some file systems.

*/
func (a *Client) FindConfigCommitlogUseoDsync(params *FindConfigCommitlogUseoDsyncParams) (*FindConfigCommitlogUseODsyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCommitlogUseoDsyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_commitlog_use_o_dsync",
		Method:             "GET",
		PathPattern:        "/config/commitlog_use_o_dsync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCommitlogUseoDsyncReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCommitlogUseODsyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCommitlogUseoDsyncDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionEnforceMinThreshold If set to true, enforce the min_threshold option for compactions strictly. If false (default), Scylla may decide to compact even if below min_threshold
*/
func (a *Client) FindConfigCompactionEnforceMinThreshold(params *FindConfigCompactionEnforceMinThresholdParams) (*FindConfigCompactionEnforceMinThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionEnforceMinThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_enforce_min_threshold",
		Method:             "GET",
		PathPattern:        "/config/compaction_enforce_min_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionEnforceMinThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionEnforceMinThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionEnforceMinThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionLargeCellWarningThresholdMb Log a warning when writing cells larger than this value
*/
func (a *Client) FindConfigCompactionLargeCellWarningThresholdMb(params *FindConfigCompactionLargeCellWarningThresholdMbParams) (*FindConfigCompactionLargeCellWarningThresholdMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionLargeCellWarningThresholdMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_large_cell_warning_threshold_mb",
		Method:             "GET",
		PathPattern:        "/config/compaction_large_cell_warning_threshold_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionLargeCellWarningThresholdMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionLargeCellWarningThresholdMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionLargeCellWarningThresholdMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionLargePartitionWarningThresholdMb Log a warning when writing partitions larger than this value
*/
func (a *Client) FindConfigCompactionLargePartitionWarningThresholdMb(params *FindConfigCompactionLargePartitionWarningThresholdMbParams) (*FindConfigCompactionLargePartitionWarningThresholdMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionLargePartitionWarningThresholdMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_large_partition_warning_threshold_mb",
		Method:             "GET",
		PathPattern:        "/config/compaction_large_partition_warning_threshold_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionLargePartitionWarningThresholdMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionLargePartitionWarningThresholdMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionLargePartitionWarningThresholdMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionLargeRowWarningThresholdMb Log a warning when writing rows larger than this value
*/
func (a *Client) FindConfigCompactionLargeRowWarningThresholdMb(params *FindConfigCompactionLargeRowWarningThresholdMbParams) (*FindConfigCompactionLargeRowWarningThresholdMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionLargeRowWarningThresholdMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_large_row_warning_threshold_mb",
		Method:             "GET",
		PathPattern:        "/config/compaction_large_row_warning_threshold_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionLargeRowWarningThresholdMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionLargeRowWarningThresholdMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionLargeRowWarningThresholdMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionPreheatKeyCache When set to true , cached row keys are tracked during compaction, and re-cached to their new positions in the compacted SSTable. If you have extremely large key caches for tables, set the value to false ; see Global row and key caches properties.
*/
func (a *Client) FindConfigCompactionPreheatKeyCache(params *FindConfigCompactionPreheatKeyCacheParams) (*FindConfigCompactionPreheatKeyCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionPreheatKeyCacheParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_preheat_key_cache",
		Method:             "GET",
		PathPattern:        "/config/compaction_preheat_key_cache",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionPreheatKeyCacheReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionPreheatKeyCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionPreheatKeyCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionRowsCountWarningThreshold Log a warning when writing a number of rows larger than this value
*/
func (a *Client) FindConfigCompactionRowsCountWarningThreshold(params *FindConfigCompactionRowsCountWarningThresholdParams) (*FindConfigCompactionRowsCountWarningThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionRowsCountWarningThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_rows_count_warning_threshold",
		Method:             "GET",
		PathPattern:        "/config/compaction_rows_count_warning_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionRowsCountWarningThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionRowsCountWarningThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionRowsCountWarningThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionStaticShares If set to higher than 0, ignore the controller's output and set the compaction shares statically. Do not set this unless you know what you are doing and suspect a problem in the controller. This option will be retired when the controller reaches more maturity
*/
func (a *Client) FindConfigCompactionStaticShares(params *FindConfigCompactionStaticSharesParams) (*FindConfigCompactionStaticSharesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionStaticSharesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_static_shares",
		Method:             "GET",
		PathPattern:        "/config/compaction_static_shares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionStaticSharesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionStaticSharesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionStaticSharesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCompactionThroughputMbPerSec Throttles compaction to the specified total throughput across the entire system. The faster you insert data, the faster you need to compact in order to keep the SSTable count down. The recommended Value is 16 to 32 times the rate of write throughput (in MBs/second). Setting the value to 0 disables compaction throttling.
Related information: Configuring compaction
*/
func (a *Client) FindConfigCompactionThroughputMbPerSec(params *FindConfigCompactionThroughputMbPerSecParams) (*FindConfigCompactionThroughputMbPerSecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCompactionThroughputMbPerSecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_compaction_throughput_mb_per_sec",
		Method:             "GET",
		PathPattern:        "/config/compaction_throughput_mb_per_sec",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCompactionThroughputMbPerSecReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCompactionThroughputMbPerSecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCompactionThroughputMbPerSecDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigConcurrentCompactors Sets the number of concurrent compaction processes allowed to run simultaneously on a node, not including validation compactions for anti-entropy repair. Simultaneous compactions help preserve read performance in a mixed read-write workload by mitigating the tendency of small SSTables to accumulate during a single long-running compaction. If compactions run too slowly or too fast, change compaction_throughput_mb_per_sec first.
*/
func (a *Client) FindConfigConcurrentCompactors(params *FindConfigConcurrentCompactorsParams) (*FindConfigConcurrentCompactorsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigConcurrentCompactorsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_concurrent_compactors",
		Method:             "GET",
		PathPattern:        "/config/concurrent_compactors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigConcurrentCompactorsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigConcurrentCompactorsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigConcurrentCompactorsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigConcurrentCounterWrites Counter writes read the current values before incrementing and writing them back. The recommended value is (16  number_of_drives) .
*/
func (a *Client) FindConfigConcurrentCounterWrites(params *FindConfigConcurrentCounterWritesParams) (*FindConfigConcurrentCounterWritesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigConcurrentCounterWritesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_concurrent_counter_writes",
		Method:             "GET",
		PathPattern:        "/config/concurrent_counter_writes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigConcurrentCounterWritesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigConcurrentCounterWritesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigConcurrentCounterWritesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigConcurrentReads For workloads with more data than can fit in memory, the bottleneck is reads fetching data from disk. Setting to (16  number_of_drives) allows operations to queue low enough in the stack so that the OS and drives can reorder them.
*/
func (a *Client) FindConfigConcurrentReads(params *FindConfigConcurrentReadsParams) (*FindConfigConcurrentReadsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigConcurrentReadsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_concurrent_reads",
		Method:             "GET",
		PathPattern:        "/config/concurrent_reads",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigConcurrentReadsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigConcurrentReadsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigConcurrentReadsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigConcurrentWrites Writes in Cassandra are rarely I/O bound, so the ideal number of concurrent writes depends on the number of CPU cores in your system. The recommended value is (8 x number_of_cpu_cores).
*/
func (a *Client) FindConfigConcurrentWrites(params *FindConfigConcurrentWritesParams) (*FindConfigConcurrentWritesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigConcurrentWritesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_concurrent_writes",
		Method:             "GET",
		PathPattern:        "/config/concurrent_writes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigConcurrentWritesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigConcurrentWritesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigConcurrentWritesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigConsistentRangemovement When set to true, range movements will be consistent. It means: 1) it will refuse to bootstrap a new node if other bootstrapping/leaving/moving nodes detected. 2) data will be streamed to a new node only from the node which is no longer responsible for the token range. Same as -Dcassandra.consistent.rangemovement in cassandra
*/
func (a *Client) FindConfigConsistentRangemovement(params *FindConfigConsistentRangemovementParams) (*FindConfigConsistentRangemovementOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigConsistentRangemovementParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_consistent_rangemovement",
		Method:             "GET",
		PathPattern:        "/config/consistent_rangemovement",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigConsistentRangemovementReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigConsistentRangemovementOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigConsistentRangemovementDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCounterCacheKeysToSave Number of keys from the counter cache to save. When disabled all keys are saved.
*/
func (a *Client) FindConfigCounterCacheKeysToSave(params *FindConfigCounterCacheKeysToSaveParams) (*FindConfigCounterCacheKeysToSaveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCounterCacheKeysToSaveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_counter_cache_keys_to_save",
		Method:             "GET",
		PathPattern:        "/config/counter_cache_keys_to_save",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCounterCacheKeysToSaveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCounterCacheKeysToSaveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCounterCacheKeysToSaveDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCounterCacheSavePeriod Duration after which Cassandra should save the counter cache (keys only). Caches are saved to saved_caches_directory.
*/
func (a *Client) FindConfigCounterCacheSavePeriod(params *FindConfigCounterCacheSavePeriodParams) (*FindConfigCounterCacheSavePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCounterCacheSavePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_counter_cache_save_period",
		Method:             "GET",
		PathPattern:        "/config/counter_cache_save_period",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCounterCacheSavePeriodReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCounterCacheSavePeriodOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCounterCacheSavePeriodDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCounterCacheSizeInMb When no value is specified a minimum of 2.5% of Heap or 50MB. If you perform counter deletes and rely on low gc_grace_seconds, you should disable the counter cache. To disable, set to 0
*/
func (a *Client) FindConfigCounterCacheSizeInMb(params *FindConfigCounterCacheSizeInMbParams) (*FindConfigCounterCacheSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCounterCacheSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_counter_cache_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/counter_cache_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCounterCacheSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCounterCacheSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCounterCacheSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCounterWriteRequestTimeoutInMs The time that the coordinator waits for counter writes to complete.
*/
func (a *Client) FindConfigCounterWriteRequestTimeoutInMs(params *FindConfigCounterWriteRequestTimeoutInMsParams) (*FindConfigCounterWriteRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCounterWriteRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_counter_write_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/counter_write_request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCounterWriteRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCounterWriteRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCounterWriteRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCPUScheduler Enable cpu scheduling
*/
func (a *Client) FindConfigCPUScheduler(params *FindConfigCPUSchedulerParams) (*FindConfigCPUSchedulerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCPUSchedulerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_cpu_scheduler",
		Method:             "GET",
		PathPattern:        "/config/cpu_scheduler",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCPUSchedulerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCPUSchedulerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCPUSchedulerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigCrossNodeTimeout Enable or disable operation timeout information exchange between nodes (to accurately measure request timeouts). If disabled Cassandra assumes the request was forwarded to the replica instantly by the coordinator.
CAUTION:
Before enabling this property make sure NTP (network time protocol) is installed and the times are synchronized between the nodes.
*/
func (a *Client) FindConfigCrossNodeTimeout(params *FindConfigCrossNodeTimeoutParams) (*FindConfigCrossNodeTimeoutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigCrossNodeTimeoutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_cross_node_timeout",
		Method:             "GET",
		PathPattern:        "/config/cross_node_timeout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigCrossNodeTimeoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigCrossNodeTimeoutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigCrossNodeTimeoutDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDataFileDirectories The directory location where table data (SSTables) is stored
*/
func (a *Client) FindConfigDataFileDirectories(params *FindConfigDataFileDirectoriesParams) (*FindConfigDataFileDirectoriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDataFileDirectoriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_data_file_directories",
		Method:             "GET",
		PathPattern:        "/config/data_file_directories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDataFileDirectoriesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDataFileDirectoriesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDataFileDirectoriesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDefaultLogLevel find config default log level API
*/
func (a *Client) FindConfigDefaultLogLevel(params *FindConfigDefaultLogLevelParams) (*FindConfigDefaultLogLevelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDefaultLogLevelParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_default_log_level",
		Method:             "GET",
		PathPattern:        "/config/default_log_level",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDefaultLogLevelReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDefaultLogLevelOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDefaultLogLevelDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDefragmentMemoryOnIdle When set to true, will defragment memory when the cpu is idle.  This reduces the amount of work Scylla performs when processing client requests.
*/
func (a *Client) FindConfigDefragmentMemoryOnIdle(params *FindConfigDefragmentMemoryOnIdleParams) (*FindConfigDefragmentMemoryOnIdleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDefragmentMemoryOnIdleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_defragment_memory_on_idle",
		Method:             "GET",
		PathPattern:        "/config/defragment_memory_on_idle",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDefragmentMemoryOnIdleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDefragmentMemoryOnIdleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDefragmentMemoryOnIdleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDeveloperMode Relax environment checks. Setting to true can reduce performance and reliability significantly.
*/
func (a *Client) FindConfigDeveloperMode(params *FindConfigDeveloperModeParams) (*FindConfigDeveloperModeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDeveloperModeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_developer_mode",
		Method:             "GET",
		PathPattern:        "/config/developer_mode",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDeveloperModeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDeveloperModeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDeveloperModeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDiskFailurePolicy Sets how Scylla responds to disk failure. Recommend settings are stop or best_effort.

 die              Shut down gossip and Thrift and kill the JVM for any file system errors or single SSTable errors, so the node can be replaced.
 stop_paranoid    Shut down gossip and Thrift even for single SSTable errors.
 stop             Shut down gossip and Thrift, leaving the node effectively dead, but available for inspection using JMX.
 best_effort      Stop using the failed disk and respond to requests based on the remaining available SSTables. This means you will see obsolete data at consistency level of ONE.
 ignore           Ignores fatal errors and lets the requests fail; all file system errors are logged but otherwise ignored. Scylla acts as in versions prior to Cassandra 1.2.

Related information: Handling Disk Failures In Cassandra 1.2 blog and Recovering from a single disk failure using JBOD.

*/
func (a *Client) FindConfigDiskFailurePolicy(params *FindConfigDiskFailurePolicyParams) (*FindConfigDiskFailurePolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDiskFailurePolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_disk_failure_policy",
		Method:             "GET",
		PathPattern:        "/config/disk_failure_policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDiskFailurePolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDiskFailurePolicyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDiskFailurePolicyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDynamicSnitchBadnessThreshold Sets the performance threshold for dynamically routing requests away from a poorly performing node. A value of 0.2 means Cassandra continues to prefer the static snitch values until the node response time is 20% worse than the best performing node. Until the threshold is reached, incoming client requests are statically routed to the closest replica (as determined by the snitch). Having requests consistently routed to a given replica can help keep a working set of data hot when read repair is less than 1.
*/
func (a *Client) FindConfigDynamicSnitchBadnessThreshold(params *FindConfigDynamicSnitchBadnessThresholdParams) (*FindConfigDynamicSnitchBadnessThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDynamicSnitchBadnessThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_dynamic_snitch_badness_threshold",
		Method:             "GET",
		PathPattern:        "/config/dynamic_snitch_badness_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDynamicSnitchBadnessThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDynamicSnitchBadnessThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDynamicSnitchBadnessThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDynamicSnitchResetIntervalInMs Time interval in milliseconds to reset all node scores, which allows a bad node to recover.
*/
func (a *Client) FindConfigDynamicSnitchResetIntervalInMs(params *FindConfigDynamicSnitchResetIntervalInMsParams) (*FindConfigDynamicSnitchResetIntervalInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDynamicSnitchResetIntervalInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_dynamic_snitch_reset_interval_in_ms",
		Method:             "GET",
		PathPattern:        "/config/dynamic_snitch_reset_interval_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDynamicSnitchResetIntervalInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDynamicSnitchResetIntervalInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDynamicSnitchResetIntervalInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigDynamicSnitchUpdateIntervalInMs The time interval for how often the snitch calculates node scores. Because score calculation is CPU intensive, be careful when reducing this interval.
*/
func (a *Client) FindConfigDynamicSnitchUpdateIntervalInMs(params *FindConfigDynamicSnitchUpdateIntervalInMsParams) (*FindConfigDynamicSnitchUpdateIntervalInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigDynamicSnitchUpdateIntervalInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_dynamic_snitch_update_interval_in_ms",
		Method:             "GET",
		PathPattern:        "/config/dynamic_snitch_update_interval_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigDynamicSnitchUpdateIntervalInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigDynamicSnitchUpdateIntervalInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigDynamicSnitchUpdateIntervalInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableCache Enable cache
*/
func (a *Client) FindConfigEnableCache(params *FindConfigEnableCacheParams) (*FindConfigEnableCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableCacheParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_cache",
		Method:             "GET",
		PathPattern:        "/config/enable_cache",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableCacheReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableCommitlog Enable commitlog
*/
func (a *Client) FindConfigEnableCommitlog(params *FindConfigEnableCommitlogParams) (*FindConfigEnableCommitlogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableCommitlogParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_commitlog",
		Method:             "GET",
		PathPattern:        "/config/enable_commitlog",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableCommitlogReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableCommitlogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableCommitlogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableDangerousDirectImportOfCassandraCounters Only turn this option on if you want to import tables from Cassandra containing counters, and you are SURE that no counters in that table were created in a version earlier than Cassandra 2.1. It is not enough to have ever since upgraded to newer versions of Cassandra. If you EVER used a version earlier than 2.1 in the cluster where these SSTables come from, DO NOT TURN ON THIS OPTION! You will corrupt your data. You have been warned.
*/
func (a *Client) FindConfigEnableDangerousDirectImportOfCassandraCounters(params *FindConfigEnableDangerousDirectImportOfCassandraCountersParams) (*FindConfigEnableDangerousDirectImportOfCassandraCountersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableDangerousDirectImportOfCassandraCountersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_dangerous_direct_import_of_cassandra_counters",
		Method:             "GET",
		PathPattern:        "/config/enable_dangerous_direct_import_of_cassandra_counters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableDangerousDirectImportOfCassandraCountersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableDangerousDirectImportOfCassandraCountersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableDangerousDirectImportOfCassandraCountersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableDeprecatedPartitioners Enable the byteordered and murmurs partitioners. These partitioners are deprecated and will be removed in a future version.
*/
func (a *Client) FindConfigEnableDeprecatedPartitioners(params *FindConfigEnableDeprecatedPartitionersParams) (*FindConfigEnableDeprecatedPartitionersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableDeprecatedPartitionersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_deprecated_partitioners",
		Method:             "GET",
		PathPattern:        "/config/enable_deprecated_partitioners",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableDeprecatedPartitionersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableDeprecatedPartitionersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableDeprecatedPartitionersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableInMemoryDataStore Enable in memory mode (system tables are always persisted)
*/
func (a *Client) FindConfigEnableInMemoryDataStore(params *FindConfigEnableInMemoryDataStoreParams) (*FindConfigEnableInMemoryDataStoreOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableInMemoryDataStoreParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_in_memory_data_store",
		Method:             "GET",
		PathPattern:        "/config/enable_in_memory_data_store",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableInMemoryDataStoreReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableInMemoryDataStoreOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableInMemoryDataStoreDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableKeyspaceColumnFamilyMetrics Enable per keyspace and per column family metrics reporting
*/
func (a *Client) FindConfigEnableKeyspaceColumnFamilyMetrics(params *FindConfigEnableKeyspaceColumnFamilyMetricsParams) (*FindConfigEnableKeyspaceColumnFamilyMetricsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableKeyspaceColumnFamilyMetricsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_keyspace_column_family_metrics",
		Method:             "GET",
		PathPattern:        "/config/enable_keyspace_column_family_metrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableKeyspaceColumnFamilyMetricsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableKeyspaceColumnFamilyMetricsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableKeyspaceColumnFamilyMetricsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableShardAwareDrivers Enable native transport drivers to use connection-per-shard for better performance
*/
func (a *Client) FindConfigEnableShardAwareDrivers(params *FindConfigEnableShardAwareDriversParams) (*FindConfigEnableShardAwareDriversOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableShardAwareDriversParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_shard_aware_drivers",
		Method:             "GET",
		PathPattern:        "/config/enable_shard_aware_drivers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableShardAwareDriversReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableShardAwareDriversOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableShardAwareDriversDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableSstableDataIntegrityCheck Enable interposer which checks for integrity of every sstable write. Performance is affected to some extent as a result. Useful to help debugging problems that may arise at another layers.
*/
func (a *Client) FindConfigEnableSstableDataIntegrityCheck(params *FindConfigEnableSstableDataIntegrityCheckParams) (*FindConfigEnableSstableDataIntegrityCheckOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableSstableDataIntegrityCheckParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_sstable_data_integrity_check",
		Method:             "GET",
		PathPattern:        "/config/enable_sstable_data_integrity_check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableSstableDataIntegrityCheckReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableSstableDataIntegrityCheckOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableSstableDataIntegrityCheckDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEnableSstablesMcFormat Enable SSTables 'mc' format to be used as the default file format
*/
func (a *Client) FindConfigEnableSstablesMcFormat(params *FindConfigEnableSstablesMcFormatParams) (*FindConfigEnableSstablesMcFormatOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEnableSstablesMcFormatParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_enable_sstables_mc_format",
		Method:             "GET",
		PathPattern:        "/config/enable_sstables_mc_format",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEnableSstablesMcFormatReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEnableSstablesMcFormatOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEnableSstablesMcFormatDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigEndpointSnitch Set to a class that implements the IEndpointSnitch. Scylla uses snitches for locating nodes and routing requests.

 SimpleSnitch: Use for single-data center deployments or single-zone in public clouds. Does not recognize data center or rack information. It treats strategy order as proximity, which can improve cache locality when disabling read repair.

 GossipingPropertyFileSnitch: Recommended for production. The rack and data center for the local node are defined in the cassandra-rackdc.properties file and propagated to other nodes via gossip. To allow migration from the PropertyFileSnitch, it uses the cassandra-topology.properties file if it is present.

 Ec2Snitch: For EC2 deployments in a single region. Loads region and availability zone information from the EC2 API. The region is treated as the data center and the availability zone as the rack. Uses only private IPs. Subsequently it does not work across multiple regions.

 Ec2MultiRegionSnitch: Uses public IPs as the broadcast_address to allow cross-region connectivity. This means you must also set seed addresses to the public IP and open the storage_port or ssl_storage_port on the public IP firewall. For intra-region traffic, Scylla switches to the private IP after establishing a connection.

 GoogleCloudSnitch: For deployments on Google Cloud Platform across one or more regions. The region is treated as a datacenter and the availability zone is treated as a rack within the datacenter. The communication should occur over private IPs within the same logical network.

 RackInferringSnitch: Proximity is determined by rack and data center, which are assumed to correspond to the 3rd and 2nd octet of each node's IP address, respectively. This snitch is best used as an example for writing a custom snitch class (unless this happens to match your deployment conventions).

Related information: Snitches

*/
func (a *Client) FindConfigEndpointSnitch(params *FindConfigEndpointSnitchParams) (*FindConfigEndpointSnitchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigEndpointSnitchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_endpoint_snitch",
		Method:             "GET",
		PathPattern:        "/config/endpoint_snitch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigEndpointSnitchReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigEndpointSnitchOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigEndpointSnitchDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigExperimental Set to true to unlock experimental features.
*/
func (a *Client) FindConfigExperimental(params *FindConfigExperimentalParams) (*FindConfigExperimentalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigExperimentalParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_experimental",
		Method:             "GET",
		PathPattern:        "/config/experimental",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigExperimentalReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigExperimentalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigExperimentalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigFdInitialValueMs The initial failure_detector interval time in milliseconds.
*/
func (a *Client) FindConfigFdInitialValueMs(params *FindConfigFdInitialValueMsParams) (*FindConfigFdInitialValueMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigFdInitialValueMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_fd_initial_value_ms",
		Method:             "GET",
		PathPattern:        "/config/fd_initial_value_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigFdInitialValueMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigFdInitialValueMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigFdInitialValueMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigFdMaxIntervalMs The maximum failure_detector interval time in milliseconds. Interval larger than the maximum will be ignored. Larger cluster may need to increase the default.
*/
func (a *Client) FindConfigFdMaxIntervalMs(params *FindConfigFdMaxIntervalMsParams) (*FindConfigFdMaxIntervalMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigFdMaxIntervalMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_fd_max_interval_ms",
		Method:             "GET",
		PathPattern:        "/config/fd_max_interval_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigFdMaxIntervalMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigFdMaxIntervalMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigFdMaxIntervalMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigFileCacheSizeInMb Total memory to use for SSTable-reading buffers.
*/
func (a *Client) FindConfigFileCacheSizeInMb(params *FindConfigFileCacheSizeInMbParams) (*FindConfigFileCacheSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigFileCacheSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_file_cache_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/file_cache_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigFileCacheSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigFileCacheSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigFileCacheSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigHintedHandoffEnabled Enable or disable hinted handoff. To enable per data center, add data center list. For example: hinted_handoff_enabled: DC1,DC2. A hint indicates that the write needs to be replayed to an unavailable node. Related information: About hinted handoff writes
*/
func (a *Client) FindConfigHintedHandoffEnabled(params *FindConfigHintedHandoffEnabledParams) (*FindConfigHintedHandoffEnabledOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigHintedHandoffEnabledParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_hinted_handoff_enabled",
		Method:             "GET",
		PathPattern:        "/config/hinted_handoff_enabled",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigHintedHandoffEnabledReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigHintedHandoffEnabledOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigHintedHandoffEnabledDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigHintedHandoffThrottleInKb Maximum throttle per delivery thread in kilobytes per second. This rate reduces proportionally to the number of nodes in the cluster. For example, if there are two nodes in the cluster, each delivery thread will use the maximum rate. If there are three, each node will throttle to half of the maximum, since the two nodes are expected to deliver hints simultaneously.
*/
func (a *Client) FindConfigHintedHandoffThrottleInKb(params *FindConfigHintedHandoffThrottleInKbParams) (*FindConfigHintedHandoffThrottleInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigHintedHandoffThrottleInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_hinted_handoff_throttle_in_kb",
		Method:             "GET",
		PathPattern:        "/config/hinted_handoff_throttle_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigHintedHandoffThrottleInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigHintedHandoffThrottleInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigHintedHandoffThrottleInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigHintsDirectory The directory where hints files are stored if hinted handoff is enabled.
*/
func (a *Client) FindConfigHintsDirectory(params *FindConfigHintsDirectoryParams) (*FindConfigHintsDirectoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigHintsDirectoryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_hints_directory",
		Method:             "GET",
		PathPattern:        "/config/hints_directory",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigHintsDirectoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigHintsDirectoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigHintsDirectoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInMemoryCompactionLimitInMb Size limit for rows being compacted in memory. Larger rows spill to disk and use a slower two-pass compaction process. When this occurs, a message is logged specifying the row key. The recommended value is 5 to 10 percent of the available Java heap size.
*/
func (a *Client) FindConfigInMemoryCompactionLimitInMb(params *FindConfigInMemoryCompactionLimitInMbParams) (*FindConfigInMemoryCompactionLimitInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInMemoryCompactionLimitInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_in_memory_compaction_limit_in_mb",
		Method:             "GET",
		PathPattern:        "/config/in_memory_compaction_limit_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInMemoryCompactionLimitInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInMemoryCompactionLimitInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInMemoryCompactionLimitInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigIncrementalBackups Backs up data updated since the last snapshot was taken. When enabled, Scylla creates a hard link to each SSTable flushed or streamed locally in a backups/ subdirectory of the keyspace data. Removing these links is the operator's responsibility.
Related information: Enabling incremental backups
*/
func (a *Client) FindConfigIncrementalBackups(params *FindConfigIncrementalBackupsParams) (*FindConfigIncrementalBackupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigIncrementalBackupsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_incremental_backups",
		Method:             "GET",
		PathPattern:        "/config/incremental_backups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigIncrementalBackupsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigIncrementalBackupsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigIncrementalBackupsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigIndexSummaryCapacityInMb Fixed memory pool size in MB for SSTable index summaries. If the memory usage of all index summaries exceeds this limit, any SSTables with low read rates shrink their index summaries to meet this limit. This is a best-effort process. In extreme conditions, Cassandra may need to use more than this amount of memory.
*/
func (a *Client) FindConfigIndexSummaryCapacityInMb(params *FindConfigIndexSummaryCapacityInMbParams) (*FindConfigIndexSummaryCapacityInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigIndexSummaryCapacityInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_index_summary_capacity_in_mb",
		Method:             "GET",
		PathPattern:        "/config/index_summary_capacity_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigIndexSummaryCapacityInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigIndexSummaryCapacityInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigIndexSummaryCapacityInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigIndexSummaryResizeIntervalInMinutes How frequently index summaries should be re-sampled. This is done periodically to redistribute memory from the fixed-size pool to SSTables proportional their recent read rates. To disable, set to -1. This leaves existing index summaries at their current sampling level.
*/
func (a *Client) FindConfigIndexSummaryResizeIntervalInMinutes(params *FindConfigIndexSummaryResizeIntervalInMinutesParams) (*FindConfigIndexSummaryResizeIntervalInMinutesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigIndexSummaryResizeIntervalInMinutesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_index_summary_resize_interval_in_minutes",
		Method:             "GET",
		PathPattern:        "/config/index_summary_resize_interval_in_minutes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigIndexSummaryResizeIntervalInMinutesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigIndexSummaryResizeIntervalInMinutesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigIndexSummaryResizeIntervalInMinutesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInitialToken Used in the single-node-per-token architecture, where a node owns exactly one contiguous range in the ring space. Setting this property overrides num_tokens.
If you not using vnodes or have num_tokens set it to 1 or unspecified (#num_tokens), you should always specify this parameter when setting up a production cluster for the first time and when adding capacity. For more information, see this parameter in the Cassandra 1.1 Node and Cluster Configuration documentation.
This parameter can be used with num_tokens (vnodes ) in special cases such as Restoring from a snapshot.
*/
func (a *Client) FindConfigInitialToken(params *FindConfigInitialTokenParams) (*FindConfigInitialTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInitialTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_initial_token",
		Method:             "GET",
		PathPattern:        "/config/initial_token",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInitialTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInitialTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInitialTokenDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInterDcStreamThroughputOutboundMegabitsPerSec Throttles all streaming file transfer between the data centers. This setting allows throttles streaming throughput betweens data centers in addition to throttling all network stream traffic as configured with stream_throughput_outbound_megabits_per_sec.
*/
func (a *Client) FindConfigInterDcStreamThroughputOutboundMegabitsPerSec(params *FindConfigInterDcStreamThroughputOutboundMegabitsPerSecParams) (*FindConfigInterDcStreamThroughputOutboundMegabitsPerSecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInterDcStreamThroughputOutboundMegabitsPerSecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_inter_dc_stream_throughput_outbound_megabits_per_sec",
		Method:             "GET",
		PathPattern:        "/config/inter_dc_stream_throughput_outbound_megabits_per_sec",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInterDcStreamThroughputOutboundMegabitsPerSecReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInterDcStreamThroughputOutboundMegabitsPerSecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInterDcStreamThroughputOutboundMegabitsPerSecDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInterDcTCPNodelay Enable or disable tcp_nodelay for inter-data center communication. When disabled larger, but fewer, network packets are sent. This reduces overhead from the TCP protocol itself. However, if cross data-center responses are blocked, it will increase latency.
*/
func (a *Client) FindConfigInterDcTCPNodelay(params *FindConfigInterDcTCPNodelayParams) (*FindConfigInterDcTCPNodelayOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInterDcTCPNodelayParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_inter_dc_tcp_nodelay",
		Method:             "GET",
		PathPattern:        "/config/inter_dc_tcp_nodelay",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInterDcTCPNodelayReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInterDcTCPNodelayOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInterDcTCPNodelayDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInternodeAuthenticator Internode authentication backend. It implements org.apache.cassandra.auth.AllowAllInternodeAuthenticator to allows or disallow connections from peer nodes.
*/
func (a *Client) FindConfigInternodeAuthenticator(params *FindConfigInternodeAuthenticatorParams) (*FindConfigInternodeAuthenticatorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInternodeAuthenticatorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_internode_authenticator",
		Method:             "GET",
		PathPattern:        "/config/internode_authenticator",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInternodeAuthenticatorReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInternodeAuthenticatorOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInternodeAuthenticatorDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInternodeCompression Controls whether traffic between nodes is compressed. The valid values are:

 all: All traffic is compressed.
 dc : Traffic between data centers is compressed.
 none : No compression.
*/
func (a *Client) FindConfigInternodeCompression(params *FindConfigInternodeCompressionParams) (*FindConfigInternodeCompressionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInternodeCompressionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_internode_compression",
		Method:             "GET",
		PathPattern:        "/config/internode_compression",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInternodeCompressionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInternodeCompressionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInternodeCompressionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInternodeRecvBuffSizeInBytes Sets the receiving socket buffer size in bytes for inter-node calls.
*/
func (a *Client) FindConfigInternodeRecvBuffSizeInBytes(params *FindConfigInternodeRecvBuffSizeInBytesParams) (*FindConfigInternodeRecvBuffSizeInBytesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInternodeRecvBuffSizeInBytesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_internode_recv_buff_size_in_bytes",
		Method:             "GET",
		PathPattern:        "/config/internode_recv_buff_size_in_bytes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInternodeRecvBuffSizeInBytesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInternodeRecvBuffSizeInBytesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInternodeRecvBuffSizeInBytesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigInternodeSendBuffSizeInBytes Sets the sending socket buffer size in bytes for inter-node calls.
When setting this parameter and internode_recv_buff_size_in_bytes, the buffer size is limited by net.core.wmem_max. When unset, buffer size is defined by net.ipv4.tcp_wmem. See man tcp and:

 /proc/sys/net/core/wmem_max
 /proc/sys/net/core/rmem_max
 /proc/sys/net/ipv4/tcp_wmem
 /proc/sys/net/ipv4/tcp_wmem

*/
func (a *Client) FindConfigInternodeSendBuffSizeInBytes(params *FindConfigInternodeSendBuffSizeInBytesParams) (*FindConfigInternodeSendBuffSizeInBytesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigInternodeSendBuffSizeInBytesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_internode_send_buff_size_in_bytes",
		Method:             "GET",
		PathPattern:        "/config/internode_send_buff_size_in_bytes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigInternodeSendBuffSizeInBytesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigInternodeSendBuffSizeInBytesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigInternodeSendBuffSizeInBytesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigJoinRing When set to true, a node will join the token ring. When set to false, a node will not join the token ring. User can use nodetool join to initiate ring joinging later. Same as -Dcassandra.join_ring in cassandra.
*/
func (a *Client) FindConfigJoinRing(params *FindConfigJoinRingParams) (*FindConfigJoinRingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigJoinRingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_join_ring",
		Method:             "GET",
		PathPattern:        "/config/join_ring",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigJoinRingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigJoinRingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigJoinRingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigKeyCacheKeysToSave Number of keys from the key cache to save. (0: all)
*/
func (a *Client) FindConfigKeyCacheKeysToSave(params *FindConfigKeyCacheKeysToSaveParams) (*FindConfigKeyCacheKeysToSaveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigKeyCacheKeysToSaveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_key_cache_keys_to_save",
		Method:             "GET",
		PathPattern:        "/config/key_cache_keys_to_save",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigKeyCacheKeysToSaveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigKeyCacheKeysToSaveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigKeyCacheKeysToSaveDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigKeyCacheSavePeriod Duration in seconds that keys are saved in cache. Caches are saved to saved_caches_directory. Saved caches greatly improve cold-start speeds and has relatively little effect on I/O.
*/
func (a *Client) FindConfigKeyCacheSavePeriod(params *FindConfigKeyCacheSavePeriodParams) (*FindConfigKeyCacheSavePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigKeyCacheSavePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_key_cache_save_period",
		Method:             "GET",
		PathPattern:        "/config/key_cache_save_period",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigKeyCacheSavePeriodReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigKeyCacheSavePeriodOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigKeyCacheSavePeriodDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigKeyCacheSizeInMb A global cache setting for tables. It is the maximum size of the key cache in memory. To disable set to 0.
Related information: nodetool setcachecapacity.
*/
func (a *Client) FindConfigKeyCacheSizeInMb(params *FindConfigKeyCacheSizeInMbParams) (*FindConfigKeyCacheSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigKeyCacheSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_key_cache_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/key_cache_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigKeyCacheSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigKeyCacheSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigKeyCacheSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLargeMemoryAllocationWarningThreshold Warn about memory allocations above this size; set to zero to disable
*/
func (a *Client) FindConfigLargeMemoryAllocationWarningThreshold(params *FindConfigLargeMemoryAllocationWarningThresholdParams) (*FindConfigLargeMemoryAllocationWarningThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLargeMemoryAllocationWarningThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_large_memory_allocation_warning_threshold",
		Method:             "GET",
		PathPattern:        "/config/large_memory_allocation_warning_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLargeMemoryAllocationWarningThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLargeMemoryAllocationWarningThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLargeMemoryAllocationWarningThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigListenAddress The IP address or hostname that Scylla binds to for connecting to other Scylla nodes. Set this parameter or listen_interface, not both. You must change the default setting for multiple nodes to communicate:

Generally set to empty. If the node is properly configured (host name, name resolution, and so on), Scylla uses InetAddress.getLocalHost() to get the local address from the system.
For a single node cluster, you can use the default setting (localhost).
If Scylla can't find the correct address, you must specify the IP address or host name.
Never specify 0.0.0.0; it is always wrong.
*/
func (a *Client) FindConfigListenAddress(params *FindConfigListenAddressParams) (*FindConfigListenAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigListenAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_listen_address",
		Method:             "GET",
		PathPattern:        "/config/listen_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigListenAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigListenAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigListenAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigListenInterface The interface that Scylla binds to for connecting to other Scylla nodes. Interfaces must correspond to a single address, IP aliasing is not supported. See listen_address.
*/
func (a *Client) FindConfigListenInterface(params *FindConfigListenInterfaceParams) (*FindConfigListenInterfaceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigListenInterfaceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_listen_interface",
		Method:             "GET",
		PathPattern:        "/config/listen_interface",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigListenInterfaceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigListenInterfaceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigListenInterfaceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigListenOnBroadcastAddress When using multiple physical network interfaces, set this to true to listen on broadcast_address in addition to the listen_address, allowing nodes to communicate in both interfaces.  Ignore this property if the network configuration automatically routes between the public and private networks such as EC2.
*/
func (a *Client) FindConfigListenOnBroadcastAddress(params *FindConfigListenOnBroadcastAddressParams) (*FindConfigListenOnBroadcastAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigListenOnBroadcastAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_listen_on_broadcast_address",
		Method:             "GET",
		PathPattern:        "/config/listen_on_broadcast_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigListenOnBroadcastAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigListenOnBroadcastAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigListenOnBroadcastAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLoadBalance CQL request load balancing: 'none' or round-robin'
*/
func (a *Client) FindConfigLoadBalance(params *FindConfigLoadBalanceParams) (*FindConfigLoadBalanceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLoadBalanceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_load_balance",
		Method:             "GET",
		PathPattern:        "/config/load_balance",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLoadBalanceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLoadBalanceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLoadBalanceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLoadRingState When set to true, load tokens and host_ids previously saved. Same as -Dcassandra.load_ring_state in cassandra.
*/
func (a *Client) FindConfigLoadRingState(params *FindConfigLoadRingStateParams) (*FindConfigLoadRingStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLoadRingStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_load_ring_state",
		Method:             "GET",
		PathPattern:        "/config/load_ring_state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLoadRingStateReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLoadRingStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLoadRingStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLogToStdout find config log to stdout API
*/
func (a *Client) FindConfigLogToStdout(params *FindConfigLogToStdoutParams) (*FindConfigLogToStdoutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLogToStdoutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_log_to_stdout",
		Method:             "GET",
		PathPattern:        "/config/log_to_stdout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLogToStdoutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLogToStdoutOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLogToStdoutDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLogToSyslog find config log to syslog API
*/
func (a *Client) FindConfigLogToSyslog(params *FindConfigLogToSyslogParams) (*FindConfigLogToSyslogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLogToSyslogParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_log_to_syslog",
		Method:             "GET",
		PathPattern:        "/config/log_to_syslog",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLogToSyslogReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLogToSyslogOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLogToSyslogDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLoggerLogLevel find config logger log level API
*/
func (a *Client) FindConfigLoggerLogLevel(params *FindConfigLoggerLogLevelParams) (*FindConfigLoggerLogLevelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLoggerLogLevelParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_logger_log_level",
		Method:             "GET",
		PathPattern:        "/config/logger_log_level",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLoggerLogLevelReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLoggerLogLevelOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLoggerLogLevelDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigLsaReclamationStep Minimum number of segments to reclaim in a single step
*/
func (a *Client) FindConfigLsaReclamationStep(params *FindConfigLsaReclamationStepParams) (*FindConfigLsaReclamationStepOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigLsaReclamationStepParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_lsa_reclamation_step",
		Method:             "GET",
		PathPattern:        "/config/lsa_reclamation_step",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigLsaReclamationStepReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigLsaReclamationStepOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigLsaReclamationStepDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMaxHintWindowInMs Maximum amount of time that hints are generates hints for an unresponsive node. After this interval, new hints are no longer generated until the node is back up and responsive. If the node goes down again, a new interval begins. This setting can prevent a sudden demand for resources when a node is brought back online and the rest of the cluster attempts to replay a large volume of hinted writes.
Related information: Failure detection and recovery
*/
func (a *Client) FindConfigMaxHintWindowInMs(params *FindConfigMaxHintWindowInMsParams) (*FindConfigMaxHintWindowInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMaxHintWindowInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_max_hint_window_in_ms",
		Method:             "GET",
		PathPattern:        "/config/max_hint_window_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMaxHintWindowInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMaxHintWindowInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMaxHintWindowInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMaxHintsDeliveryThreads Number of threads with which to deliver hints. In multiple data-center deployments, consider increasing this number because cross data-center handoff is generally slower.
*/
func (a *Client) FindConfigMaxHintsDeliveryThreads(params *FindConfigMaxHintsDeliveryThreadsParams) (*FindConfigMaxHintsDeliveryThreadsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMaxHintsDeliveryThreadsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_max_hints_delivery_threads",
		Method:             "GET",
		PathPattern:        "/config/max_hints_delivery_threads",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMaxHintsDeliveryThreadsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMaxHintsDeliveryThreadsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMaxHintsDeliveryThreadsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemoryAllocator The off-heap memory allocator. In addition to caches, this property affects storage engine meta data. Supported values:
 NativeAllocator
 JEMallocAllocator

Experiments show that jemalloc saves some memory compared to the native allocator because it is more fragmentation resistant. To use, install jemalloc as a library and modify cassandra-env.sh (instructions in file).
*/
func (a *Client) FindConfigMemoryAllocator(params *FindConfigMemoryAllocatorParams) (*FindConfigMemoryAllocatorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemoryAllocatorParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memory_allocator",
		Method:             "GET",
		PathPattern:        "/config/memory_allocator",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemoryAllocatorReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemoryAllocatorOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemoryAllocatorDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableAllocationType Specify the way Cassandra allocates and manages memtable memory. See Off-heap memtables in Cassandra 2.1. Options are:
 heap_buffers     On heap NIO (non-blocking I/O) buffers.
 offheap_buffers  Off heap (direct) NIO buffers.
 offheap_objects  Native memory, eliminating NIO buffer heap overhead.
*/
func (a *Client) FindConfigMemtableAllocationType(params *FindConfigMemtableAllocationTypeParams) (*FindConfigMemtableAllocationTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableAllocationTypeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_allocation_type",
		Method:             "GET",
		PathPattern:        "/config/memtable_allocation_type",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableAllocationTypeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableAllocationTypeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableAllocationTypeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableCleanupThreshold Ratio of occupied non-flushing memtable size to total permitted size for triggering a flush of the largest memtable. Larger values mean larger flushes and less compaction, but also less concurrent flush activity, which can make it difficult to keep your disks saturated under heavy write load.
*/
func (a *Client) FindConfigMemtableCleanupThreshold(params *FindConfigMemtableCleanupThresholdParams) (*FindConfigMemtableCleanupThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableCleanupThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_cleanup_threshold",
		Method:             "GET",
		PathPattern:        "/config/memtable_cleanup_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableCleanupThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableCleanupThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableCleanupThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableFlushQueueSize The number of full memtables to allow pending flush (memtables waiting for a write thread). At a minimum, set to the maximum number of indexes created on a single table.
Related information: Flushing data from the memtable
*/
func (a *Client) FindConfigMemtableFlushQueueSize(params *FindConfigMemtableFlushQueueSizeParams) (*FindConfigMemtableFlushQueueSizeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableFlushQueueSizeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_flush_queue_size",
		Method:             "GET",
		PathPattern:        "/config/memtable_flush_queue_size",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableFlushQueueSizeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableFlushQueueSizeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableFlushQueueSizeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableFlushStaticShares If set to higher than 0, ignore the controller's output and set the memtable shares statically. Do not set this unless you know what you are doing and suspect a problem in the controller. This option will be retired when the controller reaches more maturity
*/
func (a *Client) FindConfigMemtableFlushStaticShares(params *FindConfigMemtableFlushStaticSharesParams) (*FindConfigMemtableFlushStaticSharesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableFlushStaticSharesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_flush_static_shares",
		Method:             "GET",
		PathPattern:        "/config/memtable_flush_static_shares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableFlushStaticSharesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableFlushStaticSharesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableFlushStaticSharesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableFlushWriters Sets the number of memtable flush writer threads. These threads are blocked by disk I/O, and each one holds a memtable in memory while blocked. If you have a large Java heap size and many data directories, you can increase the value for better flush performance.
*/
func (a *Client) FindConfigMemtableFlushWriters(params *FindConfigMemtableFlushWritersParams) (*FindConfigMemtableFlushWritersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableFlushWritersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_flush_writers",
		Method:             "GET",
		PathPattern:        "/config/memtable_flush_writers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableFlushWritersReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableFlushWritersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableFlushWritersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableHeapSpaceInMb Total permitted memory to use for memtables. Triggers a flush based on memtable_cleanup_threshold. Cassandra stops accepting writes when the limit is exceeded until a flush completes. If unset, sets to default.
*/
func (a *Client) FindConfigMemtableHeapSpaceInMb(params *FindConfigMemtableHeapSpaceInMbParams) (*FindConfigMemtableHeapSpaceInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableHeapSpaceInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_heap_space_in_mb",
		Method:             "GET",
		PathPattern:        "/config/memtable_heap_space_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableHeapSpaceInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableHeapSpaceInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableHeapSpaceInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableOffheapSpaceInMb See memtable_heap_space_in_mb
*/
func (a *Client) FindConfigMemtableOffheapSpaceInMb(params *FindConfigMemtableOffheapSpaceInMbParams) (*FindConfigMemtableOffheapSpaceInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableOffheapSpaceInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_offheap_space_in_mb",
		Method:             "GET",
		PathPattern:        "/config/memtable_offheap_space_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableOffheapSpaceInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableOffheapSpaceInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableOffheapSpaceInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMemtableTotalSpaceInMb Specifies the total memory used for all memtables on a node. This replaces the per-table storage settings memtable_operations_in_millions and memtable_throughput_in_mb.
*/
func (a *Client) FindConfigMemtableTotalSpaceInMb(params *FindConfigMemtableTotalSpaceInMbParams) (*FindConfigMemtableTotalSpaceInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMemtableTotalSpaceInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_memtable_total_space_in_mb",
		Method:             "GET",
		PathPattern:        "/config/memtable_total_space_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMemtableTotalSpaceInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMemtableTotalSpaceInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMemtableTotalSpaceInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigMurmur3PartitionerIgnoreMsbBits Number of most siginificant token bits to ignore in murmur3 partitioner; increase for very large clusters
*/
func (a *Client) FindConfigMurmur3PartitionerIgnoreMsbBits(params *FindConfigMurmur3PartitionerIgnoreMsbBitsParams) (*FindConfigMurmur3PartitionerIgnoreMsbBitsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigMurmur3PartitionerIgnoreMsbBitsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_murmur3_partitioner_ignore_msb_bits",
		Method:             "GET",
		PathPattern:        "/config/murmur3_partitioner_ignore_msb_bits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigMurmur3PartitionerIgnoreMsbBitsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigMurmur3PartitionerIgnoreMsbBitsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigMurmur3PartitionerIgnoreMsbBitsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigNativeTransportMaxFrameSizeInMb The maximum size of allowed frame. Frame (requests) larger than this are rejected as invalid.
*/
func (a *Client) FindConfigNativeTransportMaxFrameSizeInMb(params *FindConfigNativeTransportMaxFrameSizeInMbParams) (*FindConfigNativeTransportMaxFrameSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigNativeTransportMaxFrameSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_native_transport_max_frame_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/native_transport_max_frame_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigNativeTransportMaxFrameSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigNativeTransportMaxFrameSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigNativeTransportMaxFrameSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigNativeTransportMaxThreads The maximum number of thread handling requests. The meaning is the same as rpc_max_threads.
Default is different (128 versus unlimited).
No corresponding native_transport_min_threads.
Idle threads are stopped after 30 seconds.

*/
func (a *Client) FindConfigNativeTransportMaxThreads(params *FindConfigNativeTransportMaxThreadsParams) (*FindConfigNativeTransportMaxThreadsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigNativeTransportMaxThreadsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_native_transport_max_threads",
		Method:             "GET",
		PathPattern:        "/config/native_transport_max_threads",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigNativeTransportMaxThreadsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigNativeTransportMaxThreadsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigNativeTransportMaxThreadsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigNativeTransportPort Port on which the CQL native transport listens for clients.
*/
func (a *Client) FindConfigNativeTransportPort(params *FindConfigNativeTransportPortParams) (*FindConfigNativeTransportPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigNativeTransportPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_native_transport_port",
		Method:             "GET",
		PathPattern:        "/config/native_transport_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigNativeTransportPortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigNativeTransportPortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigNativeTransportPortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigNativeTransportPortSsl Port on which the CQL TLS native transport listens for clients.Enabling client encryption and keeping native_transport_port_ssl disabled will use encryptionfor native_transport_port. Setting native_transport_port_ssl to a different valuefrom native_transport_port will use encryption for native_transport_port_ssl whilekeeping native_transport_port unencrypted
*/
func (a *Client) FindConfigNativeTransportPortSsl(params *FindConfigNativeTransportPortSslParams) (*FindConfigNativeTransportPortSslOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigNativeTransportPortSslParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_native_transport_port_ssl",
		Method:             "GET",
		PathPattern:        "/config/native_transport_port_ssl",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigNativeTransportPortSslReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigNativeTransportPortSslOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigNativeTransportPortSslDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigNumTokens Defines the number of tokens randomly assigned to this node on the ring when using virtual nodes (vnodes). The more tokens, relative to other nodes, the larger the proportion of data that the node stores. Generally all nodes should have the same number of tokens assuming equal hardware capability. The recommended value is 256. If unspecified (#num_tokens), Scylla uses 1 (equivalent to #num_tokens : 1) for legacy compatibility and uses the initial_token setting.
If not using vnodes, comment #num_tokens : 256 or set num_tokens : 1 and use initial_token. If you already have an existing cluster with one token per node and wish to migrate to vnodes, see Enabling virtual nodes on an existing production cluster.
Note: If using DataStax Enterprise, the default setting of this property depends on the type of node and type of install.
*/
func (a *Client) FindConfigNumTokens(params *FindConfigNumTokensParams) (*FindConfigNumTokensOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigNumTokensParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_num_tokens",
		Method:             "GET",
		PathPattern:        "/config/num_tokens",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigNumTokensReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigNumTokensOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigNumTokensDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigOverrideDecommission Set true to force a decommissioned node to join the cluster
*/
func (a *Client) FindConfigOverrideDecommission(params *FindConfigOverrideDecommissionParams) (*FindConfigOverrideDecommissionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigOverrideDecommissionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_override_decommission",
		Method:             "GET",
		PathPattern:        "/config/override_decommission",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigOverrideDecommissionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigOverrideDecommissionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigOverrideDecommissionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPartitioner Distributes rows (by partition key) across all nodes in the cluster. Any IPartitioner may be used, including your own as long as it is in the class path. For new clusters use the default partitioner.
Scylla provides the following partitioners for backwards compatibility:

 RandomPartitioner
 ByteOrderedPartitioner
 OrderPreservingPartitioner (deprecated)

Related information: Partitioners
*/
func (a *Client) FindConfigPartitioner(params *FindConfigPartitionerParams) (*FindConfigPartitionerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPartitionerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_partitioner",
		Method:             "GET",
		PathPattern:        "/config/partitioner",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPartitionerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPartitionerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPartitionerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPermissionsCacheMaxEntries Maximum cached permission entries. Must have a non-zero value if permissions caching is enabled (see a permissions_validity_in_ms description).
*/
func (a *Client) FindConfigPermissionsCacheMaxEntries(params *FindConfigPermissionsCacheMaxEntriesParams) (*FindConfigPermissionsCacheMaxEntriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPermissionsCacheMaxEntriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_permissions_cache_max_entries",
		Method:             "GET",
		PathPattern:        "/config/permissions_cache_max_entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPermissionsCacheMaxEntriesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPermissionsCacheMaxEntriesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPermissionsCacheMaxEntriesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPermissionsUpdateIntervalInMs Refresh interval for permissions cache (if enabled). After this interval, cache entries become eligible for refresh. An async reload is scheduled every permissions_update_interval_in_ms time period and the old value is returned until it completes. If permissions_validity_in_ms has a non-zero value, then this property must also have a non-zero value. It's recommended to set this value to be at least 3 times smaller than the permissions_validity_in_ms.
*/
func (a *Client) FindConfigPermissionsUpdateIntervalInMs(params *FindConfigPermissionsUpdateIntervalInMsParams) (*FindConfigPermissionsUpdateIntervalInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPermissionsUpdateIntervalInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_permissions_update_interval_in_ms",
		Method:             "GET",
		PathPattern:        "/config/permissions_update_interval_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPermissionsUpdateIntervalInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPermissionsUpdateIntervalInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPermissionsUpdateIntervalInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPermissionsValidityInMs How long permissions in cache remain valid. Depending on the authorizer, such as CassandraAuthorizer, fetching permissions can be resource intensive. Permissions caching is disabled when this property is set to 0 or when AllowAllAuthorizer is used. The cached value is considered valid as long as both its value is not older than the permissions_validity_in_ms and the cached value has been read at least once during the permissions_validity_in_ms time frame. If any of these two conditions doesn't hold the cached value is going to be evicted from the cache.
Related information: Object permissions
*/
func (a *Client) FindConfigPermissionsValidityInMs(params *FindConfigPermissionsValidityInMsParams) (*FindConfigPermissionsValidityInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPermissionsValidityInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_permissions_validity_in_ms",
		Method:             "GET",
		PathPattern:        "/config/permissions_validity_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPermissionsValidityInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPermissionsValidityInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPermissionsValidityInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPhiConvictThreshold Adjusts the sensitivity of the failure detector on an exponential scale. Generally this setting never needs adjusting.
Related information: Failure detection and recovery
*/
func (a *Client) FindConfigPhiConvictThreshold(params *FindConfigPhiConvictThresholdParams) (*FindConfigPhiConvictThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPhiConvictThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_phi_convict_threshold",
		Method:             "GET",
		PathPattern:        "/config/phi_convict_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPhiConvictThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPhiConvictThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPhiConvictThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPreheatKernelPageCache Enable or disable kernel page cache preheating from contents of the key cache after compaction. When enabled it preheats only first page (4KB) of each row to optimize for sequential access. It can be harmful for fat rows, see CASSANDRA-4937 for more details.
*/
func (a *Client) FindConfigPreheatKernelPageCache(params *FindConfigPreheatKernelPageCacheParams) (*FindConfigPreheatKernelPageCacheOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPreheatKernelPageCacheParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_preheat_kernel_page_cache",
		Method:             "GET",
		PathPattern:        "/config/preheat_kernel_page_cache",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPreheatKernelPageCacheReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPreheatKernelPageCacheOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPreheatKernelPageCacheDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPrometheusAddress Prometheus listening address
*/
func (a *Client) FindConfigPrometheusAddress(params *FindConfigPrometheusAddressParams) (*FindConfigPrometheusAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPrometheusAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_prometheus_address",
		Method:             "GET",
		PathPattern:        "/config/prometheus_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPrometheusAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPrometheusAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPrometheusAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPrometheusPort Prometheus port, set to zero to disable
*/
func (a *Client) FindConfigPrometheusPort(params *FindConfigPrometheusPortParams) (*FindConfigPrometheusPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPrometheusPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_prometheus_port",
		Method:             "GET",
		PathPattern:        "/config/prometheus_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPrometheusPortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPrometheusPortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPrometheusPortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigPrometheusPrefix Set the prefix of the exported Prometheus metrics. Changing this will break Scylla's dashboard compatibility, do not change unless you know what you are doing.
*/
func (a *Client) FindConfigPrometheusPrefix(params *FindConfigPrometheusPrefixParams) (*FindConfigPrometheusPrefixOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigPrometheusPrefixParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_prometheus_prefix",
		Method:             "GET",
		PathPattern:        "/config/prometheus_prefix",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigPrometheusPrefixReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigPrometheusPrefixOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigPrometheusPrefixDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRangeRequestTimeoutInMs The time in milliseconds that the coordinator waits for sequential or index scans to complete.
*/
func (a *Client) FindConfigRangeRequestTimeoutInMs(params *FindConfigRangeRequestTimeoutInMsParams) (*FindConfigRangeRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRangeRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_range_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/range_request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRangeRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRangeRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRangeRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReadRequestTimeoutInMs The time that the coordinator waits for read operations to complete
*/
func (a *Client) FindConfigReadRequestTimeoutInMs(params *FindConfigReadRequestTimeoutInMsParams) (*FindConfigReadRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReadRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_read_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/read_request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReadRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReadRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReadRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReduceCacheCapacityTo Sets the size percentage to which maximum cache capacity is reduced when Java heap usage reaches the threshold defined by reduce_cache_sizes_at. Together with flush_largest_memtables_at, these properties constitute an emergency measure for preventing sudden out-of-memory (OOM) errors.
*/
func (a *Client) FindConfigReduceCacheCapacityTo(params *FindConfigReduceCacheCapacityToParams) (*FindConfigReduceCacheCapacityToOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReduceCacheCapacityToParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_reduce_cache_capacity_to",
		Method:             "GET",
		PathPattern:        "/config/reduce_cache_capacity_to",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReduceCacheCapacityToReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReduceCacheCapacityToOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReduceCacheCapacityToDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReduceCacheSizesAt When Java heap usage (after a full concurrent mark sweep (CMS) garbage collection) exceeds this percentage, Cassandra reduces the cache capacity to the fraction of the current size as specified by reduce_cache_capacity_to. To disable, set the value to 1.0.
*/
func (a *Client) FindConfigReduceCacheSizesAt(params *FindConfigReduceCacheSizesAtParams) (*FindConfigReduceCacheSizesAtOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReduceCacheSizesAtParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_reduce_cache_sizes_at",
		Method:             "GET",
		PathPattern:        "/config/reduce_cache_sizes_at",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReduceCacheSizesAtReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReduceCacheSizesAtOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReduceCacheSizesAtDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReplaceAddress The listen_address or broadcast_address of the dead node to replace. Same as -Dcassandra.replace_address.
*/
func (a *Client) FindConfigReplaceAddress(params *FindConfigReplaceAddressParams) (*FindConfigReplaceAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReplaceAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_replace_address",
		Method:             "GET",
		PathPattern:        "/config/replace_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReplaceAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReplaceAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReplaceAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReplaceAddressFirstBoot Like replace_address option, but if the node has been bootstrapped successfully it will be ignored. Same as -Dcassandra.replace_address_first_boot.
*/
func (a *Client) FindConfigReplaceAddressFirstBoot(params *FindConfigReplaceAddressFirstBootParams) (*FindConfigReplaceAddressFirstBootOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReplaceAddressFirstBootParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_replace_address_first_boot",
		Method:             "GET",
		PathPattern:        "/config/replace_address_first_boot",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReplaceAddressFirstBootReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReplaceAddressFirstBootOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReplaceAddressFirstBootDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReplaceNode The UUID of the node to replace. Same as -Dcassandra.replace_node in cssandra.
*/
func (a *Client) FindConfigReplaceNode(params *FindConfigReplaceNodeParams) (*FindConfigReplaceNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReplaceNodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_replace_node",
		Method:             "GET",
		PathPattern:        "/config/replace_node",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReplaceNodeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReplaceNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReplaceNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigReplaceToken The tokens of the node to replace. Same as -Dcassandra.replace_token in cassandra.
*/
func (a *Client) FindConfigReplaceToken(params *FindConfigReplaceTokenParams) (*FindConfigReplaceTokenOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigReplaceTokenParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_replace_token",
		Method:             "GET",
		PathPattern:        "/config/replace_token",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigReplaceTokenReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigReplaceTokenOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigReplaceTokenDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRequestScheduler Defines a scheduler to handle incoming client requests according to a defined policy. This scheduler is useful for throttling client requests in single clusters containing multiple keyspaces. This parameter is specifically for requests from the client and does not affect inter-node communication. Valid values are:

 org.apache.cassandra.scheduler.NoScheduler   No scheduling takes place.
 org.apache.cassandra.scheduler.RoundRobinScheduler   Round robin of client requests to a node with a separate queue for each request_scheduler_id property.
 A Java class that implements the RequestScheduler interface.
*/
func (a *Client) FindConfigRequestScheduler(params *FindConfigRequestSchedulerParams) (*FindConfigRequestSchedulerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRequestSchedulerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_request_scheduler",
		Method:             "GET",
		PathPattern:        "/config/request_scheduler",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRequestSchedulerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRequestSchedulerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRequestSchedulerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRequestSchedulerID An identifier on which to perform request scheduling. Currently the only valid value is keyspace. See weights.
*/
func (a *Client) FindConfigRequestSchedulerID(params *FindConfigRequestSchedulerIDParams) (*FindConfigRequestSchedulerIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRequestSchedulerIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_request_scheduler_id",
		Method:             "GET",
		PathPattern:        "/config/request_scheduler_id",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRequestSchedulerIDReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRequestSchedulerIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRequestSchedulerIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRequestSchedulerOptions Contains a list of properties that define configuration options for request_scheduler:

 throttle_limit: The number of in-flight requests per client. Requests beyond this limit are queued up until running requests complete. Recommended value is ((concurrent_reads + concurrent_writes)  2)
 default_weight: (Default: 1 **)  How many requests are handled during each turn of the RoundRobin.
 weights: (Default: Keyspace: 1)  Takes a list of keyspaces. It sets how many requests are handled during each turn of the RoundRobin, based on the request_scheduler_id.
*/
func (a *Client) FindConfigRequestSchedulerOptions(params *FindConfigRequestSchedulerOptionsParams) (*FindConfigRequestSchedulerOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRequestSchedulerOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_request_scheduler_options",
		Method:             "GET",
		PathPattern:        "/config/request_scheduler_options",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRequestSchedulerOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRequestSchedulerOptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRequestSchedulerOptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRequestTimeoutInMs The default timeout for other, miscellaneous operations.
Related information: About hinted handoff writes
*/
func (a *Client) FindConfigRequestTimeoutInMs(params *FindConfigRequestTimeoutInMsParams) (*FindConfigRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRingDelayMs Time a node waits to hear from other nodes before joining the ring in milliseconds. Same as -Dcassandra.ring_delay_ms in cassandra.
*/
func (a *Client) FindConfigRingDelayMs(params *FindConfigRingDelayMsParams) (*FindConfigRingDelayMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRingDelayMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_ring_delay_ms",
		Method:             "GET",
		PathPattern:        "/config/ring_delay_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRingDelayMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRingDelayMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRingDelayMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRoleManager The role-management backend, used to maintain grantts and memberships between roles.
The available role-managers are:
 CassandraRoleManager : Stores role data in the system_auth keyspace.
*/
func (a *Client) FindConfigRoleManager(params *FindConfigRoleManagerParams) (*FindConfigRoleManagerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRoleManagerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_role_manager",
		Method:             "GET",
		PathPattern:        "/config/role_manager",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRoleManagerReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRoleManagerOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRoleManagerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRowCacheKeysToSave Number of keys from the row cache to save.
*/
func (a *Client) FindConfigRowCacheKeysToSave(params *FindConfigRowCacheKeysToSaveParams) (*FindConfigRowCacheKeysToSaveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRowCacheKeysToSaveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_row_cache_keys_to_save",
		Method:             "GET",
		PathPattern:        "/config/row_cache_keys_to_save",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRowCacheKeysToSaveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRowCacheKeysToSaveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRowCacheKeysToSaveDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRowCacheSavePeriod Duration in seconds that rows are saved in cache. Caches are saved to saved_caches_directory.
*/
func (a *Client) FindConfigRowCacheSavePeriod(params *FindConfigRowCacheSavePeriodParams) (*FindConfigRowCacheSavePeriodOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRowCacheSavePeriodParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_row_cache_save_period",
		Method:             "GET",
		PathPattern:        "/config/row_cache_save_period",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRowCacheSavePeriodReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRowCacheSavePeriodOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRowCacheSavePeriodDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRowCacheSizeInMb Maximum size of the row cache in memory. Row cache can save more time than key_cache_size_in_mb, but is space-intensive because it contains the entire row. Use the row cache only for hot rows or static rows. If you reduce the size, you may not get you hottest keys loaded on start up.
*/
func (a *Client) FindConfigRowCacheSizeInMb(params *FindConfigRowCacheSizeInMbParams) (*FindConfigRowCacheSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRowCacheSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_row_cache_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/row_cache_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRowCacheSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRowCacheSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRowCacheSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCAddress The listen address for client connections (Thrift RPC service and native transport).Valid values are:

 unset:   Resolves the address using the hostname configuration of the node. If left unset, the hostname must resolve to the IP address of this node using /etc/hostname, /etc/hosts, or DNS.
 0.0.0.0 : Listens on all configured interfaces, but you must set the broadcast_rpc_address to a value other than 0.0.0.0.
 IP address
 hostname
Related information: Network

*/
func (a *Client) FindConfigRPCAddress(params *FindConfigRPCAddressParams) (*FindConfigRPCAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_address",
		Method:             "GET",
		PathPattern:        "/config/rpc_address",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCAddressReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCAddressOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCAddressDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCInterface The listen address for client connections. Interfaces must correspond to a single address, IP aliasing is not supported. See rpc_address.
*/
func (a *Client) FindConfigRPCInterface(params *FindConfigRPCInterfaceParams) (*FindConfigRPCInterfaceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCInterfaceParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_interface",
		Method:             "GET",
		PathPattern:        "/config/rpc_interface",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCInterfaceReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCInterfaceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCInterfaceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCKeepalive Enable or disable keepalive on client connections (RPC or native).
*/
func (a *Client) FindConfigRPCKeepalive(params *FindConfigRPCKeepaliveParams) (*FindConfigRPCKeepaliveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCKeepaliveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_keepalive",
		Method:             "GET",
		PathPattern:        "/config/rpc_keepalive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCKeepaliveReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCKeepaliveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCKeepaliveDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCMaxThreads Regardless of your choice of RPC server (rpc_server_type), the number of maximum requests in the RPC thread pool dictates how many concurrent requests are possible. However, if you are using the parameter sync in the rpc_server_type, it also dictates the number of clients that can be connected. For a large number of client connections, this could cause excessive memory usage for the thread stack. Connection pooling on the client side is highly recommended. Setting a maximum thread pool size acts as a safeguard against misbehaved clients. If the maximum is reached, Cassandra blocks additional connections until a client disconnects.
*/
func (a *Client) FindConfigRPCMaxThreads(params *FindConfigRPCMaxThreadsParams) (*FindConfigRPCMaxThreadsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCMaxThreadsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_max_threads",
		Method:             "GET",
		PathPattern:        "/config/rpc_max_threads",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCMaxThreadsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCMaxThreadsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCMaxThreadsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCMinThreads Sets the minimum thread pool size for remote procedure calls.
*/
func (a *Client) FindConfigRPCMinThreads(params *FindConfigRPCMinThreadsParams) (*FindConfigRPCMinThreadsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCMinThreadsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_min_threads",
		Method:             "GET",
		PathPattern:        "/config/rpc_min_threads",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCMinThreadsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCMinThreadsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCMinThreadsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCPort Thrift port for client connections.
*/
func (a *Client) FindConfigRPCPort(params *FindConfigRPCPortParams) (*FindConfigRPCPortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCPortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_port",
		Method:             "GET",
		PathPattern:        "/config/rpc_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCPortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCPortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCPortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCRecvBuffSizeInBytes Sets the receiving socket buffer size for remote procedure calls.
*/
func (a *Client) FindConfigRPCRecvBuffSizeInBytes(params *FindConfigRPCRecvBuffSizeInBytesParams) (*FindConfigRPCRecvBuffSizeInBytesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCRecvBuffSizeInBytesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_recv_buff_size_in_bytes",
		Method:             "GET",
		PathPattern:        "/config/rpc_recv_buff_size_in_bytes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCRecvBuffSizeInBytesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCRecvBuffSizeInBytesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCRecvBuffSizeInBytesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCSendBuffSizeInBytes Sets the sending socket buffer size in bytes for remote procedure calls.
*/
func (a *Client) FindConfigRPCSendBuffSizeInBytes(params *FindConfigRPCSendBuffSizeInBytesParams) (*FindConfigRPCSendBuffSizeInBytesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCSendBuffSizeInBytesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_send_buff_size_in_bytes",
		Method:             "GET",
		PathPattern:        "/config/rpc_send_buff_size_in_bytes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCSendBuffSizeInBytesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCSendBuffSizeInBytesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCSendBuffSizeInBytesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigRPCServerType Cassandra provides three options for the RPC server. On Windows, sync is about 30% slower than hsha. On Linux, sync and hsha performance is about the same, but hsha uses less memory.

 sync    (Default One thread per Thrift connection.) For a very large number of clients, memory is the limiting factor. On a 64-bit JVM, 180KB is the minimum stack size per thread and corresponds to your use of virtual memory. Physical memory may be limited depending on use of stack space.
 hsh      Half synchronous, half asynchronous. All Thrift clients are handled asynchronously using a small number of threads that does not vary with the number of clients and thus scales well to many clients. The RPC requests are synchronous (one thread per active request).
          Note: When selecting this option, you must change the default value (unlimited) of rpc_max_threads.
 Your own RPC server: You must provide a fully-qualified class name of an o.a.c.t.TServerFactory that can create a server instance.
*/
func (a *Client) FindConfigRPCServerType(params *FindConfigRPCServerTypeParams) (*FindConfigRPCServerTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigRPCServerTypeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_rpc_server_type",
		Method:             "GET",
		PathPattern:        "/config/rpc_server_type",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigRPCServerTypeReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigRPCServerTypeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigRPCServerTypeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSavedCachesDirectory The directory location where table key and row caches are stored.
*/
func (a *Client) FindConfigSavedCachesDirectory(params *FindConfigSavedCachesDirectoryParams) (*FindConfigSavedCachesDirectoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSavedCachesDirectoryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_saved_caches_directory",
		Method:             "GET",
		PathPattern:        "/config/saved_caches_directory",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSavedCachesDirectoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSavedCachesDirectoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSavedCachesDirectoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSeedProvider The addresses of hosts deemed contact points. Scylla nodes use the -seeds list to find each other and learn the topology of the ring.

  class_name (Default: org.apache.cassandra.locator.SimpleSeedProvider)
   The class within Scylla that handles the seed logic. It can be customized, but this is typically not required.
   - seeds (Default: 127.0.0.1)    A comma-delimited list of IP addresses used by gossip for bootstrapping new nodes joining a cluster. When running multiple nodes, you must change the list from the default value. In multiple data-center clusters, the seed list should include at least one node from each data center (replication group). More than a single seed node per data center is recommended for fault tolerance. Otherwise, gossip has to communicate with another data center when bootstrapping a node. Making every node a seed node is not recommended because of increased maintenance and reduced gossip performance. Gossip optimization is not critical, but it is recommended to use a small seed list (approximately three nodes per data center).

Related information: Initializing a multiple node cluster (single data center) and Initializing a multiple node cluster (multiple data centers).
*/
func (a *Client) FindConfigSeedProvider(params *FindConfigSeedProviderParams) (*FindConfigSeedProviderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSeedProviderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_seed_provider",
		Method:             "GET",
		PathPattern:        "/config/seed_provider",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSeedProviderReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSeedProviderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSeedProviderDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigServerEncryptionOptions Enable or disable inter-node encryption. You must also generate keys and provide the appropriate key and trust store locations and passwords. No custom encryption options are currently enabled. The available options are:

internode_encryption : (Default: none ) Enable or disable encryption of inter-node communication using the TLS_RSA_WITH_AES_128_CBC_SHA cipher suite for authentication, key exchange, and encryption of data transfers. The available inter-node options are:
 all : Encrypt all inter-node communications.
 none : No encryption.
 dc : Encrypt the traffic between the data centers (server only).
 rack : Encrypt the traffic between the racks(server only).
certificate : (Default: conf/scylla.crt) The location of a PEM-encoded x509 certificate used to identify and encrypt the internode communication.
keyfile : (Default: conf/scylla.key) PEM Key file associated with certificate.
truststore : (Default: <system truststore> ) Location of the truststore containing the trusted certificate for authenticating remote servers.

The advanced settings are:

 priority_string : GnuTLS priority string controlling TLS algorithms used/allowed.
 require_client_auth : (Default: false ) Enables or disables certificate authentication.
Related information: Node-to-node encryption
*/
func (a *Client) FindConfigServerEncryptionOptions(params *FindConfigServerEncryptionOptionsParams) (*FindConfigServerEncryptionOptionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigServerEncryptionOptionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_server_encryption_options",
		Method:             "GET",
		PathPattern:        "/config/server_encryption_options",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigServerEncryptionOptionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigServerEncryptionOptionsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigServerEncryptionOptionsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigShadowRoundMs The maximum gossip shadow round time. Can be used to reduce the gossip feature check time during node boot up.
*/
func (a *Client) FindConfigShadowRoundMs(params *FindConfigShadowRoundMsParams) (*FindConfigShadowRoundMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigShadowRoundMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_shadow_round_ms",
		Method:             "GET",
		PathPattern:        "/config/shadow_round_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigShadowRoundMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigShadowRoundMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigShadowRoundMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigShutdownAnnounceInMs Time a node waits after sending gossip shutdown message in milliseconds. Same as -Dcassandra.shutdown_announce_in_ms in cassandra.
*/
func (a *Client) FindConfigShutdownAnnounceInMs(params *FindConfigShutdownAnnounceInMsParams) (*FindConfigShutdownAnnounceInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigShutdownAnnounceInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_shutdown_announce_in_ms",
		Method:             "GET",
		PathPattern:        "/config/shutdown_announce_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigShutdownAnnounceInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigShutdownAnnounceInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigShutdownAnnounceInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSkipWaitForGossipToSettle An integer to configure the wait for gossip to settle. -1: wait normally, 0: do not wait at all, n: wait for at most n polls. Same as -Dcassandra.skip_wait_for_gossip_to_settle in cassandra.
*/
func (a *Client) FindConfigSkipWaitForGossipToSettle(params *FindConfigSkipWaitForGossipToSettleParams) (*FindConfigSkipWaitForGossipToSettleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSkipWaitForGossipToSettleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_skip_wait_for_gossip_to_settle",
		Method:             "GET",
		PathPattern:        "/config/skip_wait_for_gossip_to_settle",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSkipWaitForGossipToSettleReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSkipWaitForGossipToSettleOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSkipWaitForGossipToSettleDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSnapshotBeforeCompaction Enable or disable taking a snapshot before each compaction. This option is useful to back up data when there is a data format change. Be careful using this option because Cassandra does not clean up older snapshots automatically.
Related information: Configuring compaction
*/
func (a *Client) FindConfigSnapshotBeforeCompaction(params *FindConfigSnapshotBeforeCompactionParams) (*FindConfigSnapshotBeforeCompactionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSnapshotBeforeCompactionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_snapshot_before_compaction",
		Method:             "GET",
		PathPattern:        "/config/snapshot_before_compaction",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSnapshotBeforeCompactionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSnapshotBeforeCompactionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSnapshotBeforeCompactionDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSslStoragePort The SSL port for encrypted communication. Unused unless enabled in encryption_options.
*/
func (a *Client) FindConfigSslStoragePort(params *FindConfigSslStoragePortParams) (*FindConfigSslStoragePortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSslStoragePortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_ssl_storage_port",
		Method:             "GET",
		PathPattern:        "/config/ssl_storage_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSslStoragePortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSslStoragePortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSslStoragePortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSstablePreemptiveOpenIntervalInMb When compacting, the replacement opens SSTables before they are completely written and uses in place of the prior SSTables for any range previously written. This setting helps to smoothly transfer reads between the SSTables by reducing page cache churn and keeps hot rows hot.
*/
func (a *Client) FindConfigSstablePreemptiveOpenIntervalInMb(params *FindConfigSstablePreemptiveOpenIntervalInMbParams) (*FindConfigSstablePreemptiveOpenIntervalInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSstablePreemptiveOpenIntervalInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_sstable_preemptive_open_interval_in_mb",
		Method:             "GET",
		PathPattern:        "/config/sstable_preemptive_open_interval_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSstablePreemptiveOpenIntervalInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSstablePreemptiveOpenIntervalInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSstablePreemptiveOpenIntervalInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigSstableSummaryRatio Enforces that 1 byte of summary is written for every N (2000 by default) bytes written to data file. Value must be between 0 and 1.
*/
func (a *Client) FindConfigSstableSummaryRatio(params *FindConfigSstableSummaryRatioParams) (*FindConfigSstableSummaryRatioOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigSstableSummaryRatioParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_sstable_summary_ratio",
		Method:             "GET",
		PathPattern:        "/config/sstable_summary_ratio",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigSstableSummaryRatioReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigSstableSummaryRatioOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigSstableSummaryRatioDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigStartNativeTransport Enable or disable the native transport server. Uses the same address as the rpc_address, but the port is different from the rpc_port. See native_transport_port.
*/
func (a *Client) FindConfigStartNativeTransport(params *FindConfigStartNativeTransportParams) (*FindConfigStartNativeTransportOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigStartNativeTransportParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_start_native_transport",
		Method:             "GET",
		PathPattern:        "/config/start_native_transport",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigStartNativeTransportReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigStartNativeTransportOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigStartNativeTransportDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigStartRPC Starts the Thrift RPC server
*/
func (a *Client) FindConfigStartRPC(params *FindConfigStartRPCParams) (*FindConfigStartRPCOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigStartRPCParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_start_rpc",
		Method:             "GET",
		PathPattern:        "/config/start_rpc",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigStartRPCReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigStartRPCOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigStartRPCDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigStoragePort The port for inter-node communication.
*/
func (a *Client) FindConfigStoragePort(params *FindConfigStoragePortParams) (*FindConfigStoragePortOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigStoragePortParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_storage_port",
		Method:             "GET",
		PathPattern:        "/config/storage_port",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigStoragePortReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigStoragePortOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigStoragePortDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigStreamThroughputOutboundMegabitsPerSec Throttles all outbound streaming file transfers on a node to the specified throughput. Cassandra does mostly sequential I/O when streaming data during bootstrap or repair, which can lead to saturating the network connection and degrading client (RPC) performance.
*/
func (a *Client) FindConfigStreamThroughputOutboundMegabitsPerSec(params *FindConfigStreamThroughputOutboundMegabitsPerSecParams) (*FindConfigStreamThroughputOutboundMegabitsPerSecOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigStreamThroughputOutboundMegabitsPerSecParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_stream_throughput_outbound_megabits_per_sec",
		Method:             "GET",
		PathPattern:        "/config/stream_throughput_outbound_megabits_per_sec",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigStreamThroughputOutboundMegabitsPerSecReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigStreamThroughputOutboundMegabitsPerSecOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigStreamThroughputOutboundMegabitsPerSecDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigStreamingSocketTimeoutInMs Enable or disable socket timeout for streaming operations. When a timeout occurs during streaming, streaming is retried from the start of the current file. Avoid setting this value too low, as it can result in a significant amount of data re-streaming.
*/
func (a *Client) FindConfigStreamingSocketTimeoutInMs(params *FindConfigStreamingSocketTimeoutInMsParams) (*FindConfigStreamingSocketTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigStreamingSocketTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_streaming_socket_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/streaming_socket_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigStreamingSocketTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigStreamingSocketTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigStreamingSocketTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigThriftFramedTransportSizeInMb Frame size (maximum field length) for Thrift. The frame is the row or part of the row the application is inserting.
*/
func (a *Client) FindConfigThriftFramedTransportSizeInMb(params *FindConfigThriftFramedTransportSizeInMbParams) (*FindConfigThriftFramedTransportSizeInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigThriftFramedTransportSizeInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_thrift_framed_transport_size_in_mb",
		Method:             "GET",
		PathPattern:        "/config/thrift_framed_transport_size_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigThriftFramedTransportSizeInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigThriftFramedTransportSizeInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigThriftFramedTransportSizeInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigThriftMaxMessageLengthInMb The maximum length of a Thrift message in megabytes, including all fields and internal Thrift overhead (1 byte of overhead for each frame). Message length is usually used in conjunction with batches. A frame length greater than or equal to 24 accommodates a batch with four inserts, each of which is 24 bytes. The required message length is greater than or equal to 24+24+24+24+4 (number of frames).
*/
func (a *Client) FindConfigThriftMaxMessageLengthInMb(params *FindConfigThriftMaxMessageLengthInMbParams) (*FindConfigThriftMaxMessageLengthInMbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigThriftMaxMessageLengthInMbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_thrift_max_message_length_in_mb",
		Method:             "GET",
		PathPattern:        "/config/thrift_max_message_length_in_mb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigThriftMaxMessageLengthInMbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigThriftMaxMessageLengthInMbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigThriftMaxMessageLengthInMbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigTombstoneFailureThreshold The maximum number of tombstones a query can scan before aborting.
*/
func (a *Client) FindConfigTombstoneFailureThreshold(params *FindConfigTombstoneFailureThresholdParams) (*FindConfigTombstoneFailureThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigTombstoneFailureThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_tombstone_failure_threshold",
		Method:             "GET",
		PathPattern:        "/config/tombstone_failure_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigTombstoneFailureThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigTombstoneFailureThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigTombstoneFailureThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigTombstoneWarnThreshold The maximum number of tombstones a query can scan before warning.
*/
func (a *Client) FindConfigTombstoneWarnThreshold(params *FindConfigTombstoneWarnThresholdParams) (*FindConfigTombstoneWarnThresholdOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigTombstoneWarnThresholdParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_tombstone_warn_threshold",
		Method:             "GET",
		PathPattern:        "/config/tombstone_warn_threshold",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigTombstoneWarnThresholdReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigTombstoneWarnThresholdOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigTombstoneWarnThresholdDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigTrickleFsync When doing sequential writing, enabling this option tells fsync to force the operating system to flush the dirty buffers at a set interval trickle_fsync_interval_in_kb. Enable this parameter to avoid sudden dirty buffer flushing from impacting read latencies. Recommended to use on SSDs, but not on HDDs.
*/
func (a *Client) FindConfigTrickleFsync(params *FindConfigTrickleFsyncParams) (*FindConfigTrickleFsyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigTrickleFsyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_trickle_fsync",
		Method:             "GET",
		PathPattern:        "/config/trickle_fsync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigTrickleFsyncReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigTrickleFsyncOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigTrickleFsyncDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigTrickleFsyncIntervalInKb Sets the size of the fsync in kilobytes.
*/
func (a *Client) FindConfigTrickleFsyncIntervalInKb(params *FindConfigTrickleFsyncIntervalInKbParams) (*FindConfigTrickleFsyncIntervalInKbOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigTrickleFsyncIntervalInKbParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_trickle_fsync_interval_in_kb",
		Method:             "GET",
		PathPattern:        "/config/trickle_fsync_interval_in_kb",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigTrickleFsyncIntervalInKbReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigTrickleFsyncIntervalInKbOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigTrickleFsyncIntervalInKbDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigTruncateRequestTimeoutInMs The time that the coordinator waits for truncates (remove all data from a table) to complete. The long default value allows for a snapshot to be taken before removing the data. If auto_snapshot is disabled (not recommended), you can reduce this time.
*/
func (a *Client) FindConfigTruncateRequestTimeoutInMs(params *FindConfigTruncateRequestTimeoutInMsParams) (*FindConfigTruncateRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigTruncateRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_truncate_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/truncate_request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigTruncateRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigTruncateRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigTruncateRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigViewBuilding Enable view building; should only be set to false when the node is experience issues due to view building
*/
func (a *Client) FindConfigViewBuilding(params *FindConfigViewBuildingParams) (*FindConfigViewBuildingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigViewBuildingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_view_building",
		Method:             "GET",
		PathPattern:        "/config/view_building",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigViewBuildingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigViewBuildingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigViewBuildingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigViewHintsDirectory The directory where materialized-view updates are stored while a view replica is unreachable.
*/
func (a *Client) FindConfigViewHintsDirectory(params *FindConfigViewHintsDirectoryParams) (*FindConfigViewHintsDirectoryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigViewHintsDirectoryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_view_hints_directory",
		Method:             "GET",
		PathPattern:        "/config/view_hints_directory",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigViewHintsDirectoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigViewHintsDirectoryOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigViewHintsDirectoryDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigVirtualDirtySoftLimit Soft limit of virtual dirty memory expressed as a portion of the hard limit
*/
func (a *Client) FindConfigVirtualDirtySoftLimit(params *FindConfigVirtualDirtySoftLimitParams) (*FindConfigVirtualDirtySoftLimitOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigVirtualDirtySoftLimitParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_virtual_dirty_soft_limit",
		Method:             "GET",
		PathPattern:        "/config/virtual_dirty_soft_limit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigVirtualDirtySoftLimitReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigVirtualDirtySoftLimitOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigVirtualDirtySoftLimitDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigVolatileSystemKeyspaceForTesting Don't persist system keyspace - testing only!
*/
func (a *Client) FindConfigVolatileSystemKeyspaceForTesting(params *FindConfigVolatileSystemKeyspaceForTestingParams) (*FindConfigVolatileSystemKeyspaceForTestingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigVolatileSystemKeyspaceForTestingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_volatile_system_keyspace_for_testing",
		Method:             "GET",
		PathPattern:        "/config/volatile_system_keyspace_for_testing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigVolatileSystemKeyspaceForTestingReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigVolatileSystemKeyspaceForTestingOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigVolatileSystemKeyspaceForTestingDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
FindConfigWriteRequestTimeoutInMs The time in milliseconds that the coordinator waits for write operations to complete.
Related information: About hinted handoff writes
*/
func (a *Client) FindConfigWriteRequestTimeoutInMs(params *FindConfigWriteRequestTimeoutInMsParams) (*FindConfigWriteRequestTimeoutInMsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFindConfigWriteRequestTimeoutInMsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "find_config_write_request_timeout_in_ms",
		Method:             "GET",
		PathPattern:        "/config/write_request_timeout_in_ms",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FindConfigWriteRequestTimeoutInMsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FindConfigWriteRequestTimeoutInMsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*FindConfigWriteRequestTimeoutInMsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
